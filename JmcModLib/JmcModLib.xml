<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JmcModLib</name>
    </assembly>
    <members>
        <member name="M:JmcModLib.Config.BaseEntry.GetKey(System.Type,System.String)">
            <summary>
            通过 DeclaringType 和 Name 生成唯一 Key（当前asm下唯一）
            </summary>
            <param name="declaringType">变量所在的类的类型</param>
            <param name="Name">变量的名称</param>
            <returns>返回一个形如{declaringType.FullName}.{Name}的唯一Key</returns>
        </member>
        <member name="T:JmcModLib.Config.ConfigAttribute">
            <summary>
            标记这个变量/字段是一个配置项
            </summary>
        </member>
        <member name="P:JmcModLib.Config.ConfigAttribute.DisplayName">
            <summary>
            显示名（用于放在UI上以及作为json中的key）
            </summary>
        </member>
        <member name="P:JmcModLib.Config.ConfigAttribute.Description">
            <summary>
            配置项描述（暂时未使用）
            </summary>
        </member>
        <member name="P:JmcModLib.Config.ConfigAttribute.OnChanged">
            <summary>
            配置变更时的额外回调方法名称，需要和字段/变量在同一个类中，接受参数为新赋的值，将会在实际修改值前调用（注：不需要写变更变量的操作）
            </summary>
        </member>
        <member name="P:JmcModLib.Config.ConfigAttribute.Group">
            <summary>
            配置所在的分组，默认为 DefaultGroup
            </summary>
        </member>
        <member name="F:JmcModLib.Config.ConfigAttribute.DefaultGroup">
            <summary>
            默认分组保留字，值为 "DefaultGroup"
            </summary>
        </member>
        <member name="M:JmcModLib.Config.ConfigAttribute.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            标记这个变量/字段是一个配置项
            </summary>
            <param name="displayName">显示名（用于放在UI上以及作为json中的key）</param>
            <param name="description">配置项描述（暂时未使用）</param>
            <param name="onChanged">配置变更时的额外回调方法名称，需要和字段/变量在同一个类中，接受参数为新赋的值，将会在实际修改值前调用（注：不需要写变更变量的操作）</param>
            <param name="group"> 配置所在的分组，默认为 DefaultGroup</param>
        </member>
        <member name="T:JmcModLib.Config.ConfigEntry">
            <summary>
            承载配置信息的类。
            </summary>
        </member>
        <member name="P:JmcModLib.Config.ConfigEntry.DefaultValue">
            <summary>
            字段/属性最初的默认值，用于 Reset。
            </summary>
        </member>
        <member name="T:JmcModLib.Config.ConfigManager">
            <summary>
            Config 管理器，负责注册、加载、保存配置项
            </summary>
        </member>
        <member name="E:JmcModLib.Config.ConfigManager.OnRegistered">
            <summary>
            某个ASM有配置项并且扫描完毕后广播
            </summary>
        </member>
        <member name="M:JmcModLib.Config.ConfigManager.SetStorage(JmcModLib.Config.IConfigStorage,System.Reflection.Assembly)">
            <summary>
            注册一个 Assembly 的存储实现（子 MOD 可以重写默认存储）
            </summary>
            <param name="storage">继承自IConfigStorage的类</param>
            <param name="asm">默认为调用者asm</param>
        </member>
        <member name="M:JmcModLib.Config.ConfigManager.RegisterAllInAssembly(System.Reflection.Assembly)">
            <summary>
            自动扫描当前 Assembly 内标记了 [Config] 的字段/属性
            </summary>
            <param name="asm">默认留空表示扫描当前 Assembly</param>
        </member>
        <member name="M:JmcModLib.Config.ConfigManager.Unregister(System.Reflection.Assembly)">
            <summary>
            反注册当前 Assembly 内所有配置项，并保存当前值
            </summary>
            <param name="asm"></param>
        </member>
        <member name="M:JmcModLib.Config.ConfigManager.TryGetGroupForKey(System.String,System.Reflection.Assembly)">
            <summary>
            返回某个 key 的 group（public，供 storage 调用）
            </summary>
            <param name="key">需要查询的key</param>
            <param name="asm">Assembly，留空则为当前</param>
            <returns>返回与key对应的group，如果没有找到对应的key则返回null</returns>
        </member>
        <member name="M:JmcModLib.Config.ConfigManager.GetGroups(System.Reflection.Assembly)">
            <summary>
            列出 Assembly 所有组名
            </summary>
            <param name="asm">指定程序集，留空则为调用者</param>
            <returns>组内所有 group 的集合</returns>
        </member>
        <member name="M:JmcModLib.Config.ConfigManager.GetKeys(System.String,System.Reflection.Assembly)">
            <summary>
            列出组内所有 keys
            </summary>
            <param name="group">要查询的组名</param>
            <param name="asm">指定程序集，留空则为调用者</param>
            <returns>组内所有 keys 的集合</returns>
        </member>
        <member name="M:JmcModLib.Config.ConfigManager.SyncConfigInAssembly(System.Reflection.Assembly)">
            <summary>
            将 Assembly 内所有配置项与存储介质同步，若文件中有保存的值则加载，否则保存当前值
            </summary>
            <exception cref="T:System.ArgumentNullException">asm为空抛出异常</exception>
        </member>
        <member name="M:JmcModLib.Config.ConfigManager.ResetAsm(System.Reflection.Assembly)">
            <summary>
            重置当前 Assembly 内所有配置项为默认值
            </summary>
        </member>
        <member name="M:JmcModLib.Config.ConfigManager.GetValue(System.String,System.Reflection.Assembly)">
            <summary>
            获取Key对应变量的值，如果Key不存在，会输出一条Warn
            </summary>
            <param name="key">目标变量的Key，可以通过ConfigEntry.GetKey构造</param>
            <param name="asm">指定程序集，留空则为调用者</param>
            <returns>如果Key不存在，会输出一条Warn并返回空，否则返回对应值</returns>
        </member>
        <member name="M:JmcModLib.Config.ConfigManager.SetValue(System.String,System.Object,System.Reflection.Assembly)">
            <summary>
            为Key代表的配置的值设置新的值，如果Key不存在，会输出一条Warn
            </summary>
            <param name="key">目标变量的Key，可以通过ConfigEntry.GetKey构造</param>
            <param name="value">新的值</param>
            <param name="asm">指定程序集，留空则为调用者</param>
            <returns>如果Key不存在，会输出一条Warn并返回空，否则返回对应值</returns>
        </member>
        <member name="T:JmcModLib.Config.IConfigStorage">
            <summary>
            配置存储接口
            </summary>
        </member>
        <member name="M:JmcModLib.Config.IConfigStorage.Save(System.String,System.String,System.Object,System.Reflection.Assembly)">
            <summary>
            根据 key 和 group 保存配置值
            </summary>
        </member>
        <member name="M:JmcModLib.Config.IConfigStorage.TryLoad(System.String,System.String,System.Type,System.Object@,System.Reflection.Assembly)">
            <summary>
            保存配置值
            </summary>
            <param name="key">配置项的key</param>
            <param name="group">配置项的组</param>
            <param name="type">值的类型</param>
            <param name="value">输出的值</param>
            <param name="asm">相关的程序集</param>
            <returns>是否成功加载配置</returns>
        </member>
        <member name="M:JmcModLib.Config.IConfigStorage.Exists(System.Reflection.Assembly)">
            <summary>
            是否存在assembly对应的配置文件
            </summary>
        </member>
        <member name="M:JmcModLib.Config.IConfigStorage.Flush(System.Reflection.Assembly)">
            <summary>
            真实地将缓存写入存储介质
            </summary>
        </member>
        <member name="T:JmcModLib.Config.NewtonsoftConfigStorage">
            <summary>
            以 Newtonsoft.Json 作为序列化工具的配置存储实现
            </summary>
        </member>
        <member name="M:JmcModLib.Config.NewtonsoftConfigStorage.#ctor(System.String)">
            <summary>
            初始化一个 NewtonsoftConfigStorage 实例
            </summary>
            <param name="rootFolder">根目录</param>
        </member>
        <member name="M:JmcModLib.Config.NewtonsoftConfigStorage.Exists(System.Reflection.Assembly)">
            <summary>
            是否存在assembly对应的配置文件
            </summary>
            <param name="asm">默认则为调用者</param>
            <returns>返回结果对应的bool</returns>
        </member>
        <member name="M:JmcModLib.Config.NewtonsoftConfigStorage.TryLoad(System.String,System.String,System.Type,System.Object@,System.Reflection.Assembly)">
            <summary>
            尝试读取配置项
            </summary>
            <param name="key">json文件中的key</param>
            <param name="group">配置项所属的组名</param>
            <param name="type">期望的值类型</param>
            <param name="value">返回的配置项值</param>
            <param name="asm">调用的程序集，默认是调用者</param>
            <returns>如果加载成功，则返回true</returns>
        </member>
        <member name="M:JmcModLib.Config.NewtonsoftConfigStorage.Save(System.String,System.String,System.Object,System.Reflection.Assembly)">
            <summary>
            保存配置项到缓存
            </summary>
            <param name="key">json文件中的key</param>
            <param name="group">配置项所属的组名</param>
            <param name="value">返回的配置项值</param>
            <param name="asm">调用的程序集，默认是调用者</param>
        </member>
        <member name="M:JmcModLib.Config.NewtonsoftConfigStorage.Flush(System.Reflection.Assembly)">
            <summary>
            真正将缓存写回文件
            </summary>
            <param name="asm">指定asm，默认为调用者</param>
        </member>
        <member name="M:JmcModLib.Config.UI.ConfigUIManager.Register(System.Reflection.Assembly)">
            <summary>
            若ASM存在条目，广播此ASM
            </summary>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingAPI.Init(Duckov.Modding.ModInfo)">
            <summary>
            初始化API
            </summary>
            <param name="modInfo">mod信息</param>
            <returns>是否成功初始化</returns>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingAPI.AddDropdownList(Duckov.Modding.ModInfo,System.String,System.String,System.Collections.Generic.List{System.String},System.String,System.Action{System.String})">
            <summary>
            添加一个下拉列表控件
            </summary>
            <param name="modInfo">对应的MOD</param>
            <param name="key">控件key</param>
            <param name="description">描述文本</param>
            <param name="options">选项列表</param>
            <param name="defaultValue">当前值</param>
            <param name="onValueChange">值改变时的回调函数</param>
            <returns></returns>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingAPI.AddSlider(Duckov.Modding.ModInfo,System.String,System.String,System.Single,UnityEngine.Vector2,System.Action{System.Single},System.Int32,System.Int32)">
            <summary>
            添加一个浮点数滑块控件
            </summary>
            <param name="modInfo">对应的MOD</param>
            <param name="key">控件key</param>
            <param name="description">描述文本</param>
            <param name="defaultValue">当前值</param>
            <param name="sliderRange">滑块范围</param>
            <param name="onValueChange">值改变时的回调函数</param>
            <param name="decimalPlaces">小数位数</param>
            <param name="characterLimit">输入字符限制</param>
            <returns></returns>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingAPI.AddSlider(Duckov.Modding.ModInfo,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Action{System.Int32},System.Int32)">
            <summary>
            添加一个整数滑块控件
            </summary>
            <param name="modInfo">对应的MOD</param>
            <param name="key">控件key</param>
            <param name="description">描述文本</param>
            <param name="defaultValue">当前值</param>
            <param name="minValue">最小值</param>
            <param name="maxValue">最大值</param>
            <param name="onValueChange">值改变时的回调函数</param>
            <param name="characterLimit">输入字符限制</param>
            <returns></returns>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingAPI.AddToggle(Duckov.Modding.ModInfo,System.String,System.String,System.Boolean,System.Action{System.Boolean})">
            <summary>
            添加一个开关控件
            </summary>
            <param name="modInfo">对应的MOD</param>
            <param name="key">控件key</param>
            <param name="description">描述文本</param>
            <param name="enable">当前值</param>
            <param name="onValueChange">值改变时的回调函数</param>
            <returns></returns>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingAPI.AddKeybinding(Duckov.Modding.ModInfo,System.String,System.String,UnityEngine.KeyCode,System.Action{UnityEngine.KeyCode})">
            <summary>
            添加一个按键绑定控件，默认值None
            </summary>
            <param name="modInfo">对应的MOD</param>
            <param name="key">控件key</param>
            <param name="description">描述文本</param>
            <param name="keyCode">当前值</param>
            <param name="onValueChange">值改变时的回调函数</param>
            <returns></returns>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingAPI.AddKeybinding(Duckov.Modding.ModInfo,System.String,System.String,UnityEngine.KeyCode,UnityEngine.KeyCode,System.Action{UnityEngine.KeyCode})">
            <summary>
            添加一个带默认值的按键绑定控件
            </summary>
            <param name="modInfo">对应的MOD</param>
            <param name="key">控件key</param>
            <param name="description">描述文本</param>
            <param name="keyCode">当前值</param>
            <param name="defaultKeyCode">默认值</param>
            <param name="onValueChange">值改变时的回调函数</param>
            <returns></returns>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingAPI.AddInput(Duckov.Modding.ModInfo,System.String,System.String,System.String,System.Int32,System.Action{System.String})">
            <summary>
            添加一个输入框控件
            </summary>
            <param name="modInfo">对应的MOD</param>
            <param name="key">控件key</param>
            <param name="description">描述文本</param>
            <param name="defaultValue">当前值</param>
            <param name="characterLimit">输入字符限制</param>
            <param name="onValueChange">值改变时的回调函数</param>
            <returns></returns>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingAPI.AddButton(Duckov.Modding.ModInfo,System.String,System.String,System.String,System.Action)">
            <summary>
            添加一个按钮控件
            </summary>
            <param name="modInfo">对应的MOD</param>
            <param name="key">控件key</param>
            <param name="description">描述文本</param>
            <param name="buttonText">按钮文本</param>
            <param name="onClickButton">点击时的回调函数</param>
            <returns></returns>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingAPI.AddGroup(Duckov.Modding.ModInfo,System.String,System.String,System.Collections.Generic.List{System.String},System.Single,System.Boolean,System.Boolean)">
            <summary>
            添加一个分组控件，用于将多个控件组织在一起
            </summary>
            <param name="modInfo">对应的MOD</param>
            <param name="key">控件key</param>
            <param name="description">描述文本</param>
            <param name="keys">包含的控件键列表(暂不支持嵌套Group)</param>
            <param name="scale">缩放比例(相对于mod标题)，最大0.9f</param>
            <param name="topInsert">是否插入到顶部</param>
            <param name="open">是否默认展开</param>
            <returns></returns>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingAPI.GetValue``1(Duckov.Modding.ModInfo,System.String,System.Action{``0})">
            <summary>
            获取指定key的配置值
            </summary>
            <param name="modInfo">对应的MOD</param>
            <param name="key">控件key</param>
            <param name="callback">回调函数返回结果</param>
            <typeparam name="T">值类型</typeparam>
            <returns></returns>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingAPI.SetValue``1(Duckov.Modding.ModInfo,System.String,``0,System.Action{System.Boolean})">
            <summary>
            设置指定key的配置值，单方面通知控件更新
            </summary>
            <param name="modInfo">对应的MOD</param>
            <param name="key">控件key</param>
            <param name="value">设置值</param>
            <param name="callback">回调函数返回是否成功</param>
            <typeparam name="T">值类型</typeparam>
            <returns></returns>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingAPI.HasConfig(Duckov.Modding.ModInfo)">
            <summary>
            检查是否存在此mod的配置文件
            </summary>
            <returns></returns>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingAPI.GetSavedValue``1(Duckov.Modding.ModInfo,System.String,``0@)">
            <summary>
            获取已保存的配置值
            </summary>
            <param name="modInfo">对应的MOD</param>
            <param name="key">控件key</param>
            <param name="value">保存的值</param>
            <typeparam name="T">值类型</typeparam>
            <returns></returns>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingAPI.RemoveUI(Duckov.Modding.ModInfo,System.String,System.Action{System.Boolean})">
            <summary>
            移除指定键对应的UI控件
            </summary>
            <param name="modInfo">对应的MOD</param>
            <param name="key">控件key</param>
            <param name="callback">回调函数返回操作结果</param>
            <returns></returns>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingAPI.RemoveMod(Duckov.Modding.ModInfo,System.Action{System.Boolean})">
            <summary>
            移除整个模组的UI配置,当禁用此mod时，ModSetting会自动移除相对应的UI，一般来说不需要调用，除非想要主动移除mod所有UI
            </summary>
            <param name="modInfo">对应的MOD</param>
            <param name="callback">回调函数返回操作结果</param>
            <returns></returns>
        </member>
        <member name="T:JmcModLib.Config.UI.ModSetting.ModSettingLinker">
            <summary>
            负责将 DuckSort 的 ModConfig 注册到 ModSetting。
            </summary>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingLinker.IsRegistered(System.Reflection.Assembly)">
            <summary>
            判断有没有注册过 Asm到Linker
            </summary>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingLinker.IsInitialized(System.Reflection.Assembly)">
            <summary>
            判断有没有将 ASM注册到 ModSetting UI 并且已经初始化完成。
            </summary>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingLinker.InitMod(System.Reflection.Assembly)">
            <summary>
            将指定程序集的 ModSetting 注册到 ModSetting UI。
            </summary>
        </member>
        <member name="T:JmcModLib.Config.UI.PendingUIEntry`2">
            <summary>
            一个用于存储待处理 UI 配置项的类。
            </summary>
        </member>
        <member name="T:JmcModLib.Config.UI.UIBaseAttribute">
            <summary>
            整体标签基类
            </summary>
        </member>
        <member name="T:JmcModLib.Config.UI.UIConfigAttribute">
            <summary>
            ui 配置属性基类。
            </summary>
        </member>
        <member name="T:JmcModLib.Config.UI.UIFloatSliderAttribute">
            <summary>
            float 滑动条属性
            </summary>
        </member>
        <member name="M:JmcModLib.Config.UI.UIFloatSliderAttribute.#ctor(System.Single,System.Single,System.Int32,System.Int32)">
            <summary>
            float 滑动条属性
            </summary>
            <param name="min">滑动下限</param>
            <param name="max">滑动上限</param>
            <param name="decimalPlaces">小数位数</param>
            <param name="characterLimit">输入字符限制</param>
        </member>
        <member name="T:JmcModLib.Config.UI.UIIntSliderAttribute">
            <summary>
            Int 滑动条属性
            </summary>
        </member>
        <member name="M:JmcModLib.Config.UI.UIIntSliderAttribute.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Int 滑动条属性
            </summary>
            <param name="min">滑动下限</param>
            <param name="max">滑动上限</param>
            <param name="characterLimit">输入字符限制</param>
        </member>
        <member name="T:JmcModLib.Config.UI.UIToggleAttribute">
            <summary>
            开关属性
            </summary>
        </member>
        <member name="T:JmcModLib.Config.UI.UIDropdownAttribute">
            <summary>
            添加一个下拉框属性，仅支持枚举类型
            </summary>
        </member>
        <member name="T:JmcModLib.Config.UI.UIKeyBindAttribute">
            <summary>
            绑定按键属性
            </summary>
        </member>
        <member name="T:JmcModLib.Config.UI.UIInputAttribute">
            <summary>
            输入框属性
            </summary>
        </member>
        <member name="M:JmcModLib.Config.UI.UIInputAttribute.#ctor(System.Int32)">
            <summary>
            初始化一个输入框属性
            </summary>
            <param name="characterLimit">输入字符限制</param>
        </member>
        <member name="T:JmcModLib.Core.ModRegistry">
            <summary>
            使用前应该先注册类的信息，
            <example>
            示例：
            <code>
            ModRegistry.Register(VersionInfo.Name, VersionInfo.Version);
            </code>
            </example>
            </summary>
        </member>
        <member name="E:JmcModLib.Core.ModRegistry.OnRegistered">
            <summary>
            当一个 MOD 完成注册后触发。
            参数：Assembly（唯一标识MOD）（该MOD元信息）
            </summary>
        </member>
        <member name="E:JmcModLib.Core.ModRegistry.OnUnRegistered">
            <summary>
            反注册 MOD 时触发。
            </summary>
        </member>
        <member name="M:JmcModLib.Core.ModRegistry.Register(Duckov.Modding.ModInfo,System.String,System.String,JmcModLib.Utils.LogLevel,System.Reflection.Assembly)">
            <summary>
            调用Register注册元信息，至少需要在OnAfterSetup及以后调用
            </summary>
            <param name="info"> MOD的info信息，可以在OnAfterSetup及以后取得，OnEnable阶段该值未初始化，不可用 </param>
            <param name="name">MOD的名称，留空将在modinfo中取得，若也为空将在assembly中取得</param>
            <param name="version">MOD的版本号，留空或填null则会被默认置为1.0.0</param>
            <param name="level">期待显示的默认打印级别，留空则打印Info及以上</param>
            <param name="assembly">程序集，留空自动获取</param>
        </member>
        <member name="M:JmcModLib.Core.ModRegistry.IsRegistered(System.Reflection.Assembly)">
            <summary>
            判断是否已注册
            </summary>
        </member>
        <member name="M:JmcModLib.Core.ModRegistry.UnRegister(System.Reflection.Assembly)">
            <summary>
            反注册程序集的MOD信息，留空则反注册调用者的程序集
            </summary>
        </member>
        <member name="M:JmcModLib.Core.ModRegistry.GetModInfo(System.Reflection.Assembly)">
            <summary>
            获取程序集的MOD信息，留空则返回调用者的信息
            </summary>
        </member>
        <member name="M:JmcModLib.Core.ModRegistry.SetLogLevel(JmcModLib.Utils.LogLevel,System.Reflection.Assembly)">
            <summary>
            设置程序集的打印等级，默认为调用者
            </summary>
        </member>
        <member name="M:JmcModLib.Core.ModRegistry.GetTag(System.Reflection.Assembly)">
            <summary>
            获取由程序集Mod名与版本号拼接成的标签，留空则返回调用者的Tag
            </summary>
            <returns> 返回$"[{info.Name} v{info.Version}]"，若未注册，返回空 </returns>
        </member>
        <member name="T:JmcModLib.Core.ModRegistry.Modinfo">
            <summary>
            Mod的元信息
            </summary>
            <param name="Info">Mod的详细信息</param>
            <param name="Name">Mod名</param>
            <param name="Version">Mod版本号</param>
            <param name="Level">Mod打印级别</param>
        </member>
        <member name="M:JmcModLib.Core.ModRegistry.Modinfo.#ctor(Duckov.Modding.ModInfo,System.String,System.String,JmcModLib.Utils.LogLevel)">
            <summary>
            Mod的元信息
            </summary>
            <param name="Info">Mod的详细信息</param>
            <param name="Name">Mod名</param>
            <param name="Version">Mod版本号</param>
            <param name="Level">Mod打印级别</param>
        </member>
        <member name="P:JmcModLib.Core.ModRegistry.Modinfo.Info">
            <summary>Mod的详细信息</summary>
        </member>
        <member name="P:JmcModLib.Core.ModRegistry.Modinfo.Name">
            <summary>Mod名</summary>
        </member>
        <member name="P:JmcModLib.Core.ModRegistry.Modinfo.Version">
            <summary>Mod版本号</summary>
        </member>
        <member name="P:JmcModLib.Core.ModRegistry.Modinfo.Level">
            <summary>Mod打印级别</summary>
        </member>
        <member name="T:JmcModLib.ModBehaviour">
            <summary>
            入口类
            </summary>
        </member>
        <member name="M:JmcModLib.ModBehaviour.OnAfterSetup">
            <summary>
            在模组设置完成后调用
            </summary>
        </member>
        <member name="F:JmcModLib.Reflection.ReflectionAccessorBase.DefaultFlags">
            <summary>
            默认搜索所有静态、实例、公有、私有，不搜索继承
            </summary>
        </member>
        <member name="P:JmcModLib.Reflection.ReflectionAccessorBase.Name">
            <summary>
            成员名称
            </summary>
        </member>
        <member name="P:JmcModLib.Reflection.ReflectionAccessorBase.DeclaringType">
            <summary>
            声明该成员的类型
            </summary>
        </member>
        <member name="P:JmcModLib.Reflection.ReflectionAccessorBase.IsStatic">
            <summary>
            该成员是否为静态
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.ReflectionAccessorBase.GetAttribute``1">
            <summary>
            获取指定类型的第一个 Attribute。如果不存在返回 null。
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.ReflectionAccessorBase.HasAttribute``1">
            <summary>
            判断是否具有某个 Attribute。
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.ReflectionAccessorBase.GetAttributes(System.Type)">
            <summary>
            获取指定类型的所有 Attribute。如果 type 为 null，返回所有 Attribute。
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.ReflectionAccessorBase.GetAllAttributes">
            <summary>
            获取所有 Attribute（等价于 GetAttributes(null)）
            </summary>
        </member>
        <member name="T:JmcModLib.Reflection.ReflectionAccessorBase`2">
            <summary>
            MemberAccessor 和 MethodAccessor 的公共基类
            </summary>
        </member>
        <member name="P:JmcModLib.Reflection.ReflectionAccessorBase`2.CacheCount">
            <summary>
            获取当前缓存的条目数量
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.ReflectionAccessorBase`2.GetOrCreate(`0,System.Func{`0,`1})">
            <summary>
            从 MemberInfo 获取 TAccessor 并缓存（由子类实现具体的创建逻辑）
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.ReflectionAccessorBase`2.ClearCache">
            <summary>
            清空缓存（用于测试或内存管理）
            </summary>
        </member>
        <member name="P:JmcModLib.Reflection.ReflectionAccessorBase`2.Member">
            <summary>
            底层的 MemberInfo（FieldInfo/PropertyInfo/MethodInfo 等）
            </summary>
        </member>
        <member name="P:JmcModLib.Reflection.ReflectionAccessorBase`2.Name">
            <summary>
            成员名称
            </summary>
        </member>
        <member name="P:JmcModLib.Reflection.ReflectionAccessorBase`2.DeclaringType">
            <summary>
            声明该成员的类型
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.ReflectionAccessorBase`2.GetAttributes(System.Type)">
            <summary>
            获取指定类型的所有 Attribute。如果 type 为 null，返回所有 Attribute。
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.ReflectionAccessorBase`2.#ctor(`0)">
            <summary>
            构造基类
            </summary>
            <param name="member">成员信息</param>
            <exception cref="T:System.ArgumentNullException"> 若 member 为 null </exception>
        </member>
        <member name="T:JmcModLib.Reflection.MemberAccessor">
            <summary>
            字段 / 属性 的统一高性能访问器。
            </summary>
        </member>
        <member name="P:JmcModLib.Reflection.MemberAccessor.MemberType">
            <summary>
            成员数据类型（不是MemberTypes）
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MemberAccessor.GetValue(System.Object)">
            <summary>
            获取值。
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MemberAccessor.SetValue(System.Object,System.Object)">
            <summary>
            设置值。
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MemberAccessor.Get(System.Type,System.String)">
            <summary>
            获得一个成员访问器（自动缓存）。
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MemberAccessor.Get(System.Reflection.MemberInfo)">
            <summary>
            按MemberInfo获取访问去
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MemberAccessor.GetAll(System.Type,System.Reflection.BindingFlags)">
            <summary>
            获取某类型的所有方法（可选择包含继承方法）
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MemberAccessor.GetAll``1(System.Reflection.BindingFlags)">
            <summary>
            泛型版本
            </summary>
        </member>
        <member name="T:JmcModLib.Reflection.MethodAccessor">
            <summary>
            用于反射方法
            </summary>
        </member>
        <member name="P:JmcModLib.Reflection.MethodAccessor.IsStatic">
            <summary>
            是否为静态
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.Get(System.Reflection.MethodInfo)">
            <summary>
            从 MethodInfo 获取 MethodAccessor 并缓存
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.GetAll(System.Type,System.Reflection.BindingFlags)">
            <summary>
            获取某类型的所有方法（可选择包含继承方法）
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.GetAll``1(System.Reflection.BindingFlags)">
            <summary>
            泛型版本
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.Get(System.Type,System.String,System.Type[])">
            <summary>
            获取类型下方法的 MethodAccessor（可匹配参数类型）
            </summary>
            <param name="type"> 类类型 </param>
            <param name="methodName"> 方法名 </param>
            <param name="parameterTypes"> 方法的参数列表类型，泛型位将跳过，不填则默认找第一个（在有多个重载的情况下） </param>
            <returns> 返回一个MethodAccessor，若是泛型方法，需要进一步Make，否则可以直接invoke </returns>
            <exception cref="T:System.MissingMethodException"></exception>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.MakeGeneric(System.Type[])">
            <summary>
            构造泛型方法实例
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">
            <summary>
            调用方法（实例/静态）
            </summary>
            <param name="instance"> 实例对象，静态则留空 </param>
            <param name="args"> 调用的参数列表 </param>
            <returns> 返回方法的返回值 </returns>
            <exception cref="T:System.ArgumentNullException"> 实例方法需要实例对象 </exception>
            <exception cref="T:System.InvalidOperationException"> 泛型方法需要先MakeGeneric(...)  </exception>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.CreateInvoker(System.Reflection.MethodInfo)">
            <summary>
            创建方法调用委托
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.EmitUnboxWithEnumSupport(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>
            对普通值类型执行 Unbox_Any
            对 enum 正确执行底层类型转换 + enum 转换
            对引用类型执行 Castclass
            </summary>
        </member>
        <member name="T:JmcModLib.Utils.ComponentHelper">
            <summary>
            一些用来往GameObject里加Component的方法
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ComponentHelper.AddComponentIfNeeded``1(UnityEngine.GameObject,System.Action{``0},System.String)">
             <summary>
             确保组件被添加并初始化
             <example>
             示例：
             <code>
             var ret = Utils.ComponentHelper.AddComponentIfNeeded&lt;UI.ModEntryDragHandler>(__instance.gameObject, handler => handler.Setup(__instance), "ModEntryDragHandler 已添加并初始化");
             if (!ret)
             {
                 ModLogger.Debug("ModEntryDragHandler已经被添加过了");
             }
             </code>
             </example>
             </summary>
             <typeparam name="T">组件类型</typeparam>
             <param name="instance">目标 GameObject</param>
             <param name="initializeMethod">初始化方法，接受该组件的实例作为参数</param>
             <param name="info">可选的参数，成功添加的日志信息，如果有传递，会打印到Debug日志中</param>
             <returns>如果组件已存在返回 false，成功添加返回 true</returns>
            
        </member>
        <member name="M:JmcModLib.Utils.ComponentHelper.AddComponentAlways``1(UnityEngine.GameObject,System.Action{``0},System.String)">
            <summary>
            若GameObject中已存在component，删除后再添加，否则直接添加
            </summary>
            <typeparam name="T">组件类型</typeparam>
            <param name="instance">目标 GameObject</param>
            <param name="initializeMethod">初始化方法，接受该组件的实例作为参数</param>
            <param name="info">可选的参数，成功添加的日志信息，如果有传递，会打印到Debug日志中</param>
            <returns>如果是新增的，返回true，否则返回false</returns>
        </member>
        <member name="M:JmcModLib.Utils.ComponentHelper.AddComponentOr``1(UnityEngine.GameObject,System.Action{``0},System.Action{``0},System.String)">
            <summary>
            如果GameObject中已存在component组件，执行onComponentFound，否则添加
            </summary>
            <typeparam name="T">组件类型</typeparam>
            <param name="instance">目标 GameObject</param>
            <param name="initializeMethod">初始化方法，接受该组件的实例作为参数</param>
            <param name="onComponentFound">待执行的函数</param>
            <param name="info">可选的参数，成功添加的日志信息，如果有传递，会打印到Debug日志中</param>
            <returns></returns>
        </member>
        <member name="T:JmcModLib.Utils.L10n">
            <summary>
            多语言本地化系统（按程序集管理）
            </summary>
        </member>
        <member name="P:JmcModLib.Utils.L10n.CurrentLanguage">
            <summary>
            当前语言
            </summary>
        </member>
        <member name="E:JmcModLib.Utils.L10n.LanguageChanged">
            <summary>
            语言变更后的事件，不建议订阅<c>LocalizationManager.CurrentLanguage</c>，不然可能本地化不及时生效
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.L10n.Dispose">
            <summary>
            当 JmcModLib 或宿主 MOD 卸载时调用
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.L10n.IsRegistered(System.Reflection.Assembly)">
            <summary>
            判断某程序集是否已经被注册过语言文件。
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.L10n.Register(System.String,UnityEngine.SystemLanguage,System.Reflection.Assembly)">
            <summary>
            注册当前程序集的本地化文件夹路径（例如 "Mods/MyMod/Lang"）。
            若找不到指定的备用语言对应的文件，会将指定文件夹的第一个 `.csv` 文件作为备用语言文件。
            </summary>
            <param name="langFolderRelative">存放本地化csv的相对路径，默认为“Lang”</param>
            <param name="fallbackLang">指定某语言文件不存在时的备份语言，默认为英语</param>
            <param name="assembly">程序集，默认为调用者</param>
        </member>
        <member name="M:JmcModLib.Utils.L10n.UnRegister(System.Reflection.Assembly)">
            <summary>
            反注册当前程序集的本地化数据。
            </summary>
            <param name="assembly">程序集，默认为调用者</param>
        </member>
        <member name="M:JmcModLib.Utils.L10n.Get(System.String,System.Reflection.Assembly)">
            <summary>
            翻译当前程序集的键值
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.L10n.Unregister(System.Reflection.Assembly)">
            <summary>
            卸载当前程序集的本地化
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.L10n.OnLanguageChanged(UnityEngine.SystemLanguage)">
            <summary>
            当游戏语言切换时自动更新
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.L10n.LoadForPath(System.String)">
            <summary>
            从路径加载
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.L10n.LoadForAssembly(System.Reflection.Assembly,UnityEngine.SystemLanguage)">
            <summary>
            加载指定程序集和语言
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.L10n.GetLanguageFileName(UnityEngine.SystemLanguage)">
            <summary>
            根据 SystemLanguage 返回语言文件名
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.L10n.LoadCSV(System.String)">
            <summary>
            使用游戏自带的 CSV 工具加载
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.L10n.Exist(System.Reflection.Assembly)">
            <summary>
            返回程序集是否注册了本地化文本
            </summary>
            <param name="asm"></param>
            <returns></returns>
        </member>
        <member name="T:JmcModLib.Utils.LogLevel">
            <summary>
            打印级别
            </summary>
        </member>
        <member name="F:JmcModLib.Utils.LogLevel.Trace">
            <summary>
            主要用于打印出函数入函数
            </summary>
        </member>
        <member name="F:JmcModLib.Utils.LogLevel.Debug">
            <summary>
            Debug
            </summary>
        </member>
        <member name="F:JmcModLib.Utils.LogLevel.Info">
            <summary>
            Info
            </summary>
        </member>
        <member name="F:JmcModLib.Utils.LogLevel.Warn">
            <summary>
            Warn
            </summary>
        </member>
        <member name="F:JmcModLib.Utils.LogLevel.Error">
            <summary>
            Error
            </summary>
        </member>
        <member name="F:JmcModLib.Utils.LogLevel.None">
            <summary>
            None
            </summary>
        </member>
        <member name="T:JmcModLib.Utils.ModLogger">
            <summary>
            一个打印类
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ModLogger.Trace(System.String,System.Reflection.Assembly,System.String,System.String,System.Int32)">
            <summary>
            使用Trace输出
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ModLogger.Debug(System.String,System.Reflection.Assembly,System.String,System.String,System.Int32)">
            <summary>
            使用Debug输出
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ModLogger.Info(System.String,System.Reflection.Assembly,System.String,System.String,System.Int32)">
            <summary>
            Info输出
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ModLogger.Warn(System.String,System.Exception,System.Reflection.Assembly,System.String,System.String,System.Int32)">
            <summary>
            Warn输出
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ModLogger.Error(System.String,System.Exception,System.Reflection.Assembly,System.String,System.String,System.Int32)">
            <summary>
            Error输出，其中若传递异常，会换行并输出异常
            </summary>
        </member>
        <member name="T:JmcModLib.Utils.ReflectionHelper">
            <summary>
            Emit实现带缓存的反射辅助库
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ReflectionHelper.GetFieldValue``1(System.Object,System.String)">
            <summary>
            获取obj名为fieldName的字段
            </summary>
            <typeparam name="T">字段的类型</typeparam>
            <param name="obj">目标对象</param>
            <param name="fieldName">字段名称</param>
            <returns>返回被获取的字段</returns>
            <exception cref="T:System.ArgumentNullException">传入obj为空</exception>
            <exception cref="T:System.MissingFieldException">不存在字段</exception>
            <exception cref="T:System.InvalidCastException">字段类型不匹配</exception>
        </member>
        <member name="M:JmcModLib.Utils.ReflectionHelper.SetFieldValue``1(System.Object,System.String,``0)">
            <summary>
            设置字段的值为value
            </summary>
            <typeparam name="T">字段类型</typeparam>
            <param name="obj">目标对象</param>
            <param name="fieldName">字段名称</param>
            <param name="value">待设置的值</param>
            <exception cref="T:System.ArgumentNullException">传入obj为空</exception>
            <exception cref="T:System.MissingFieldException">不存在字段</exception>
        </member>
        <member name="M:JmcModLib.Utils.ReflectionHelper.CallMethod``1(System.Object,System.String,System.Object[])">
            <summary>
            获取一个有返回值的Method
            </summary>
            <typeparam name="T">返回值类型</typeparam>
            <param name="obj">目标对象</param>
            <param name="methodName">方法名</param>
            <param name="args">传入的参数</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">obj为空</exception>
            <exception cref="T:System.MissingMethodException">方法不存在</exception>
            <exception cref="T:System.InvalidCastException">返回值类型不匹配</exception>
        </member>
        <member name="M:JmcModLib.Utils.ReflectionHelper.CallVoidMethod(System.Object,System.String,System.Object[])">
            <summary>
            获取一个void返回值的方法
            </summary>
            <param name="obj">目标对象</param>
            <param name="methodName">方法名</param>
            <param name="args">传入的参数</param>
            <exception cref="T:System.ArgumentNullException">obj为空</exception>
            <exception cref="T:System.MissingMethodException">方法不存在</exception>
        </member>
        <member name="M:JmcModLib.Utils.ReflectionHelper.CallStaticMethod``1(System.Type,System.String,System.Object[])">
            <summary>
            调用一个带有返回值的静态方法
            </summary>
            <typeparam name="T">返回值类型</typeparam>
            <param name="type">类型</param>
            <param name="methodName">方法名称</param>
            <param name="args">参数列表</param>
            <returns></returns>
            <exception cref="T:System.MissingMethodException">找不到静态方法</exception>
            <exception cref="T:System.InvalidCastException">返回值不正确</exception>
        </member>
        <member name="M:JmcModLib.Utils.ReflectionHelper.CallStaticMethodWithOut``1(System.Type,System.String,System.Object[],``0@)">
            <summary>
            调用一个带out参数的静态方法
            </summary>
            <typeparam name="TOut"></typeparam>
            <param name="type"></param>
            <param name="methodName"></param>
            <param name="args"></param>
            <param name="outValue"></param>
            <returns></returns>
            <exception cref="T:System.MissingMethodException"></exception>
            <exception cref="T:System.InvalidCastException"></exception>
        </member>
        <member name="T:ExprHelper">
            <summary>
            解析表达式的一些库
            </summary>
        </member>
        <member name="P:ExprHelper.EnableCache">
            <summary>
            是否开启缓存，不建议修改
            </summary>
        </member>
        <member name="P:ExprHelper.AccessMode">
            <summary>
            生成Accessor的后端，不建议修改，默认为Emit
            </summary>
        </member>
        <member name="T:ExprHelper.MemberAccessMode">
            <summary>
            生成Accessor的后端模式
            </summary>
        </member>
        <member name="F:ExprHelper.MemberAccessMode.Reflection">
            <summary>
            直接反射
            </summary>
        </member>
        <member name="F:ExprHelper.MemberAccessMode.ExpressionTree">
            <summary>
            表达式树实现
            </summary>
        </member>
        <member name="F:ExprHelper.MemberAccessMode.Emit">
            <summary>
            Emit实现
            </summary>
        </member>
        <member name="F:ExprHelper.MemberAccessMode.Default">
            <summary>
            默认值，默认为Emit
            </summary>
        </member>
        <member name="M:ExprHelper.Expect``2">
            <summary>
            仅供检查类型别名嵌套关系是否正确的辅助函数
            </summary>
        </member>
        <member name="T:ExprHelper.MemberAccessors">
            <summary>
            类型访问器辅助类
            </summary>
        </member>
        <member name="M:ExprHelper.MemberAccessors.#ctor(System.Delegate,System.Delegate)">
            <summary>
            类型访问器辅助类
            </summary>
        </member>
        <member name="M:ExprHelper.GetOrCreateAccessors``1(System.Linq.Expressions.Expression{System.Func{``0}},System.Reflection.Assembly)">
            <summary>
            从一个变量自动构造getter函数与setter函数，调用形式形如：
            <example>
            <code>
             var (gf, sf) = ExprHelper.GetOrCreateAccessors(() => obj.Field)
            </code>
            </example>
            </summary>
            <typeparam name="T">变量的类型</typeparam>
            <param name="expr">构造表达式，形如<c>() => obj.field </c></param>
            <param name="assembly">程序集，默认为调用者</param>
            <returns>返回由getter和setter组成的对，若目标为只读或者只写，在调用错误访问器时会抛出InvalidOperationException异常</returns>
            <exception cref="T:System.ArgumentException">表达式格式不正确、目标字段或属性不正确</exception>
            <exception cref="T:System.InvalidOperationException">实例对象为空、模式选择不正确</exception>
        </member>
        <member name="M:ExprHelper.GetOrCreateAccessors``1(System.Linq.Expressions.Expression{System.Func{``0}},System.Boolean@,System.Reflection.Assembly)">
            <summary>
            从一个变量自动构造getter函数与setter函数，并检查是否命中缓存，调用形式形如：
            <example>
            <code>
            var (g, s) = ExprHelper.GetOrCreateAccessors(() => a.Field, out bool hit);
            </code>
            </example>
            </summary>
            <typeparam name="T">变量的类型</typeparam>
            <param name="expr">构造表达式，形如<c>() => obj.field </c></param>
            <param name="cacheHit">是否命中缓存</param>
            <param name="assembly">程序集，默认为调用者</param>
            <returns>返回由getter和setter组成的对，若目标为只读或者只写，在调用错误访问器时会抛出InvalidOperationException异常</returns>
            <exception cref="T:System.ArgumentException">表达式格式不正确、目标字段或属性不正确</exception>
            <exception cref="T:System.InvalidOperationException">实例对象为空、模式选择不正确</exception>
        </member>
        <member name="M:ExprHelper.CreateAccessorsByExpressionTree``1(System.Reflection.MemberInfo,System.Object)">
            <summary>
            创建 getter/setter
            </summary>
        </member>
        <member name="M:ExprHelper.CreateAccessorsByEmit``1(System.Reflection.MemberInfo,System.Object)">
            <summary>
            使用 DynamicMethod + IL Emit 创建 getter/setter
            </summary>
        </member>
        <member name="M:ExprHelper.ClearAssemblyCache(System.Reflection.Assembly)">
            <summary>
            清理某个 Assembly 的缓存
            </summary>
        </member>
        <member name="M:ExprHelper.ClearAll">
            <summary>
            清理所有缓存
            </summary>
        </member>
    </members>
</doc>
