<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JmcModLib</name>
    </assembly>
    <members>
        <member name="T:JmcModLib.Config.ConfigAttribute">
            <summary>
            标记这个变量/字段是一个配置项
            </summary>
            <remarks>
            标记这个变量/字段是一个配置项
            </remarks>
            <param name="displayName">显示名（用于放在UI上以及作为json中的key）</param>
            <param name="onChanged">配置变更时的额外回调方法名称，需要和字段/变量在同一个类中，接受参数为新赋的值，将会在实际修改值前调用（注：不需要写变更变量的操作）</param>
            <param name="group"> 配置所在的分组，默认为 DefaultGroup</param>
        </member>
        <member name="M:JmcModLib.Config.ConfigAttribute.#ctor(System.String,System.String,System.String)">
            <summary>
            标记这个变量/字段是一个配置项
            </summary>
            <remarks>
            标记这个变量/字段是一个配置项
            </remarks>
            <param name="displayName">显示名（用于放在UI上以及作为json中的key）</param>
            <param name="onChanged">配置变更时的额外回调方法名称，需要和字段/变量在同一个类中，接受参数为新赋的值，将会在实际修改值前调用（注：不需要写变更变量的操作）</param>
            <param name="group"> 配置所在的分组，默认为 DefaultGroup</param>
        </member>
        <member name="P:JmcModLib.Config.ConfigAttribute.DisplayName">
            <summary>
            显示名（用于放在UI上以及作为json中的key）
            </summary>
        </member>
        <member name="P:JmcModLib.Config.ConfigAttribute.OnChanged">
            <summary>
            配置变更时的额外回调方法名称，需要和字段/变量在同一个类中，接受参数为新赋的值，将会在实际修改值前调用（注：不需要写变更变量的操作）
            </summary>
        </member>
        <member name="P:JmcModLib.Config.ConfigAttribute.Group">
            <summary>
            配置所在的分组，默认为 DefaultGroup
            </summary>
        </member>
        <member name="F:JmcModLib.Config.ConfigAttribute.DefaultGroup">
            <summary>
            默认分组保留字，值为 "DefaultGroup"
            </summary>
        </member>
        <member name="M:JmcModLib.Config.ConfigAttribute.IsValidMethod(System.Reflection.MethodInfo,System.Type,System.Nullable{JmcModLib.Utils.LogLevel}@,System.String@)">
            <summary>
            检查 MethodInfo 是否满足 回调 的要求（静态、void、单参）
            </summary>
            <param name="method">要检查的方法</param>
            <param name="type"></param>
            <param name="level">返回日志等级，若验证成功返回空，若返回值不匹配返回WARN</param>
            <param name="errorMessage">返回错误描述，验证成功返回空</param>
            <returns>如果警告等级在WARN以下返回 true，否则返回 false</returns>
        </member>
        <member name="T:JmcModLib.Config.ConfigManager">
            <summary>
            Config 管理器，负责注册、加载、保存配置项
            </summary>
        </member>
        <member name="E:JmcModLib.Config.ConfigManager.OnRegistered">
            <summary>
            某个ASM有配置项并且扫描完毕后广播
            </summary>
        </member>
        <member name="M:JmcModLib.Config.ConfigManager.SetStorage(JmcModLib.Config.Storage.IConfigStorage,System.Reflection.Assembly)">
            <summary>
            注册一个 Assembly 的存储实现（子 MOD 可以重写默认存储）
            </summary>
            <param name="storage">继承自IConfigStorage的类</param>
            <param name="asm">默认为调用者asm</param>
        </member>
        <member name="M:JmcModLib.Config.ConfigManager.Unregister(System.Reflection.Assembly)">
            <summary>
            反注册当前 Assembly 内所有配置项，并保存当前值
            </summary>
            <param name="asm"></param>
        </member>
        <member name="M:JmcModLib.Config.ConfigManager.TryGetGroupForKey(System.String,System.Reflection.Assembly)">
            <summary>
            返回某个 key 的 group（public，供 storage 调用）
            </summary>
            <param name="key">需要查询的key</param>
            <param name="asm">Assembly，留空则为当前</param>
            <returns>返回与key对应的group，如果没有找到对应的key则返回null</returns>
        </member>
        <member name="M:JmcModLib.Config.ConfigManager.GetGroups(System.Reflection.Assembly)">
            <summary>
            列出 Assembly 所有组名
            </summary>
            <param name="asm">指定程序集，留空则为调用者</param>
            <returns>组内所有 group 的集合</returns>
        </member>
        <member name="M:JmcModLib.Config.ConfigManager.GetKeys(System.String,System.Reflection.Assembly)">
            <summary>
            列出组内所有 keys
            </summary>
            <param name="group">要查询的组名</param>
            <param name="asm">指定程序集，留空则为调用者</param>
            <returns>组内所有 keys 的集合</returns>
        </member>
        <member name="M:JmcModLib.Config.ConfigManager.ResetAsm(System.Reflection.Assembly)">
            <summary>
            重置当前 Assembly 内所有配置项为默认值
            </summary>
        </member>
        <member name="M:JmcModLib.Config.ConfigManager.GetKey(System.String,System.String)">
            <summary>
            通过显示名称和组名获取Key
            </summary>
            <param name="displayName"> 显示名称 </param>
            <param name="group"> 组名，可选 </param>
            <returns> 直接构造一个key，不检验是否存在 </returns>
        </member>
        <member name="M:JmcModLib.Config.ConfigManager.GetValue(System.String,System.Reflection.Assembly)">
            <summary>
            获取Key对应变量的值，如果Key不存在，会输出一条Warn
            </summary>
            <param name="key">目标变量的Key，可以通过BaseEntry.GetKey构造</param>
            <param name="asm">指定程序集，留空则为调用者</param>
            <returns>如果Key不存在，会输出一条Warn并返回空，否则返回对应值</returns>
        </member>
        <member name="M:JmcModLib.Config.ConfigManager.SetValue(System.String,System.Object,System.Reflection.Assembly)">
            <summary>
            为Key代表的配置的值设置新的值，如果Key不存在，会输出一条Warn
            </summary>
            <param name="key">目标变量的Key，可以通过ConfigEntry.GetKey构造</param>
            <param name="value">新的值</param>
            <param name="asm">指定程序集，留空则为调用者</param>
        </member>
        <member name="M:JmcModLib.Config.ConfigManager.RegisterButton(System.String,System.Action,System.String,System.String,System.Reflection.Assembly,System.Reflection.Assembly)">
            <summary>
            注册一个按钮，相关文本将自动调用本地化文件
            </summary>
            <param name="description"> 按钮的描述文本 </param>
            <param name="action"> 按钮的行为 </param>
            <param name="buttonText"> 按钮上的文本 </param>
            <param name="group"> 按钮所在的组，留空为默认 </param>
            <param name="asm"> 注册的Assembly集，留空为调用者 </param>
            <param name="l10nAssembly"> 本地化指定的程序集，留空则与主程序集相同 </param>
            <returns> 返回按钮的Key </returns>
        </member>
        <member name="M:JmcModLib.Config.ConfigManager.RegisterConfigImpl``1(System.Reflection.Assembly,System.String,``0,System.Func{``0},System.Action{``0},JmcModLib.Config.UI.UIConfigAttribute,System.String,System.Action{``0},System.Reflection.Assembly)">
            <summary>
            通过对象注册单条配置信息的实现
            </summary>
        </member>
        <member name="M:JmcModLib.Config.ConfigManager.RegisterConfigImpl``1(System.Reflection.Assembly,System.String,``0,System.String,JmcModLib.Config.UI.UIConfigAttribute,System.Action{``0},System.Reflection.Assembly)">
            <summary>
            通过值注册单条配置信息的实现
            </summary>
        </member>
        <member name="M:JmcModLib.Config.ConfigManager.RegisterConfig``1(System.String,System.Func{``0},System.Action{``0},System.String,System.Reflection.Assembly)">
            <summary>
            仅注册配置项，不绑定任何UI，仅用于持久化
            </summary>
            <remarks> 可为实例对象，但应当自行维护生命周期，保证自注册至MOD卸载期间不被销毁。 </remarks>
            <typeparam name="T"> 注册的值的类型 </typeparam>
            <param name="displayName"> 用作在持久化文本中的条目名称 </param>
            <param name="getter"> 维护的值的getter，在设置初始值以及卸载阶段调用一次以同步文件 </param>
            <param name="setter"> 维护的值的setter，用户若需要在代码中改值，最好使用GetValue(key)，但直接修改自己的值也会在最后保存文件时同步保存，只是不能同步UI </param>
            <param name="group"> 值所在的组，若不需要分组则留空 </param>
            <param name="asm"> 注册的程序集，留空则为调用者本身 </param>
            
            <returns> 返回配置项的Key，可以通过GetValue/SetValue函数查询系统内的值 </returns>
        </member>
        <member name="M:JmcModLib.Config.ConfigManager.RegisterConfig``1(System.String,System.Linq.Expressions.Expression{System.Func{``0}},System.String,System.Reflection.Assembly)">
            <summary>
            通过形如 `() => ClassName.StaticName / () => InstanceName.FieldName` 的表达式注册一个配置项，字段/属性/静态/实例均可。不绑定任何UI，仅用于持久化
            </summary>
            <remarks> 可为实例对象，但应当自行维护生命周期，保证自注册至MOD卸载期间不被销毁。 </remarks>
            <typeparam name="T"> 注册的值的类型 </typeparam>
            <param name="displayName"> 用作在持久化文本中的条目名称 </param>
            <param name="expr"> 形如 `() => ClassName.StaticName / () => InstanceName.FieldName` 的表达式 </param>
            <param name="group"> 值所在的组，若不需要分组则留空 </param>
            <param name="asm"> 注册的程序集，留空则为调用者本身 </param>
            <returns> 返回配置项的Key，可以通过GetValue/SetValue函数查询系统内的值 </returns>
        </member>
        <member name="M:JmcModLib.Config.ConfigManager.RegisterConfig``1(JmcModLib.Config.UI.UIConfigAttribute{``0},System.String,System.Func{``0},System.Action{``0},System.String,System.Action{``0},System.Reflection.Assembly,System.Reflection.Assembly)">
            <summary>
            通过getter/setter 注册一个配置项。
            </summary>
            <remarks> 可为实例对象，但应当自行维护生命周期，保证自注册至MOD卸载期间不被销毁。 </remarks>
            <typeparam name="T"> 注册的值的类型 </typeparam>
            <param name="uiAttr"> 需要注册UI的Attribute，相关文本将自动调用本地化文件 </param>
            <param name="displayName"> 显示文本，用于保存以及显示在UI系统里 </param>
            <param name="getter"> 维护的值的getter，在设置初始值以及卸载阶段调用一次以同步文件 </param>
            <param name="setter"> 维护的值的setter，用户若需要在代码中改值，最好使用GetValue(key)，但直接修改自己的值也会在最后保存文件时同步保存，只是不能同步UI </param>
            <param name="group"> 值所在的组，若不需要分组则留空 </param>
            <param name="action"> 若需注册UI且需要额外的回调函数，则填入，若不需要则留空，此处禁止调用ConfigManager的SetVal </param>
            <param name="asm"> 注册的程序集，留空则为调用者本身 </param>
            <param name="l10nAsm"> 本地化指定的程序集，留空则与主程序集相同 </param>
            <returns> 返回配置项的Key，可以通过GetValue/SetValue函数查询系统内的值 </returns>
        </member>
        <member name="M:JmcModLib.Config.ConfigManager.RegisterConfig``1(JmcModLib.Config.UI.UIDropdownAttribute,System.String,System.Func{``0},System.Action{``0},System.String,System.Action{``0},System.Reflection.Assembly,System.Reflection.Assembly)">
            <summary>
            通过枚举值注册一个下拉列表，将自动从枚举值生成下拉列表。
            </summary>
            <typeparam name="TEnum"> 用于配置的枚举类型 </typeparam>
            <param name="uiAttr"> 需要注册UI的Attribute，相关文本将自动调用本地化文件 </param>
            <param name="displayName"> 显示文本，用于保存以及显示在UI系统里 </param>
            <param name="getter"> 维护的值的getter，在设置初始值以及卸载阶段调用一次以同步文件 </param>
            <param name="setter"> 维护的值的setter，用户若需要在代码中改值，最好使用GetValue(key)，但直接修改自己的值也会在最后保存文件时同步保存，只是不能同步UI </param>
            <param name="group"> 值所在的组，若不需要分组则留空 </param>
            <param name="action"> 若需注册UI且需要额外的回调函数，则填入，若不需要则留空，此处禁止调用ConfigManager的SetVal </param>
            <param name="asm"> 注册的程序集，留空则为调用者本身 </param>
            <param name="l10nAsm"> 本地化指定的程序集，留空则与主程序集相同 </param>
            <returns> 返回配置项的Key，可以通过GetValue/SetValue函数查询系统内的值 </returns>
        </member>
        <member name="M:JmcModLib.Config.ConfigManager.RegisterConfig``1(JmcModLib.Config.UI.UIConfigAttribute{``0},System.String,``0,System.String,System.Action{``0},System.Reflection.Assembly,System.Reflection.Assembly)">
            <summary>
            直接通过非空值注册一个配置项，由此MOD自行维护该值的生命周期，可通过 GetValue/SetValue 查询修改。
            </summary>
            <typeparam name="T"> 注册的配置项类型 </typeparam>
            <param name="uiAttr"> 需要注册UI的Attribute，相关文本将自动调用本地化文件 </param>
            <param name="displayName"> 显示文本，用于保存以及显示在UI系统里 </param>
            <param name="defaultValue"> 默认值 </param>
            <param name="group"> 值所在的组，若不需要分组则留空 </param>
            <param name="action"> 若需注册UI且需要额外的回调函数，则填入，若不需要则留空，此处禁止调用ConfigManager的SetVal </param>
            <param name="asm"> 注册的程序集，留空则为调用者本身 </param>
            <param name="l10nAsm"> 本地化指定的程序集，留空则与主程序集相同 </param>
            <returns> 返回配置项的Key，可以通过GetValue/SetValue函数查询系统内的值 </returns>
        </member>
        <member name="M:JmcModLib.Config.ConfigManager.RegisterConfig``1(JmcModLib.Config.UI.UIDropdownAttribute,System.String,``0,System.String,System.Action{``0},System.Reflection.Assembly,System.Reflection.Assembly)">
            <summary>
            用一个非空枚举值生成下拉列表注册一个配置项，由此MOD自行维护该值的生命周期，可通过 GetValue/SetValue 查询修改。
            </summary>
            <typeparam name="TEnum"> 用于配置的枚举类型 </typeparam>
            <param name="uiAttr"> 需要注册UI的Attribute，相关文本将自动调用本地化文件 </param>
            <param name="displayName"> 显示文本，用于保存以及显示在UI系统里 </param>
            <param name="defaultValue"> 默认枚举值 </param>
            <param name="group"> 值所在的组，若不需要分组则留空 </param>
            <param name="action"> 若需注册UI且需要额外的回调函数，则填入，若不需要则留空，此处禁止调用ConfigManager的SetVal </param>
            <param name="asm"> 注册的程序集，留空则为调用者本身 </param>
            <param name="l10nAsm"> 本地化指定的程序集，留空则与主程序集相同 </param>
            <returns> 返回配置项的Key，可以通过GetValue/SetValue函数查询系统内的值 </returns>
        </member>
        <member name="M:JmcModLib.Config.ConfigManager.RegisterConfig``1(JmcModLib.Config.UI.UIConfigAttribute{``0},System.String,System.Linq.Expressions.Expression{System.Func{``0}},System.String,System.Action{``0},System.Reflection.Assembly,System.Reflection.Assembly)">
            <summary>
            通过形如 `() => ClassName.StaticName / () => InstanceName.FieldName` 的表达式注册一个配置项，字段/属性/静态/实例均可。
            </summary>
            <remarks> 可为实例对象，但应当自行维护生命周期，保证自注册至MOD卸载期间不被销毁。 </remarks>
            <typeparam name="T"> 注册的配置项类型 </typeparam>
            <param name="uiAttr"> 需要注册UI的Attribute，相关文本将自动调用本地化文件 </param>
            <param name="displayName"> 显示文本，用于保存以及显示在UI系统里 </param>
            <param name="expr"> 形如 `() => ClassName.StaticName / () => InstanceName.FieldName` 的表达式 </param>
            <param name="group"> 值所在的组，若不需要分组则留空 </param>
            <param name="action"> 若需注册UI且需要额外的回调函数，则填入，若不需要则留空，此处禁止调用ConfigManager的SetVal </param>
            <param name="asm"> 注册的程序集，留空则为调用者本身 </param>
            <param name="l10nAsm"> 本地化指定的程序集，留空则与主程序集相同 </param>
            <returns> 返回配置项的Key，可以通过GetValue/SetValue函数查询系统内的值 </returns>
            <exception cref="T:System.ArgumentException"> 传递的表达式不合法 </exception>
        </member>
        <member name="M:JmcModLib.Config.ConfigManager.RegisterConfig``1(JmcModLib.Config.UI.UIDropdownAttribute,System.String,System.Linq.Expressions.Expression{System.Func{``0}},System.String,System.Action{``0},System.Reflection.Assembly,System.Reflection.Assembly)">
            <summary>
            通过形如 `() => ClassName.StaticName / () => InstanceName.FieldName` 的表达式注册一个下拉列表，字段/属性/静态/实例均可。
            </summary>
            <typeparam name="TEnum"> 用于配置的枚举类型 </typeparam>
            <param name="uiAttr"> 需要注册UI的Attribute，相关文本将自动调用本地化文件 </param>
            <param name="displayName"> 显示文本，用于保存以及显示在UI系统里 </param>
            <param name="expr"> 形如 `() => ClassName.StaticName / () => InstanceName.FieldName` 的表达式 </param>
            <param name="group"> 值所在的组，若不需要分组则留空 </param>
            <param name="action"> 若需注册UI且需要额外的回调函数，则填入，若不需要则留空，此处禁止调用ConfigManager的SetVal </param>
            <param name="asm"> 注册的程序集，留空则为调用者本身 </param>
            <returns> 返回配置项的Key，可以通过GetValue/SetValue函数查询系统内的值 </returns>
        </member>
        <member name="T:JmcModLib.Config.Entry.BaseEntry">
            <summary>
            所有配置条目的基类
            </summary>
        </member>
        <member name="M:JmcModLib.Config.Entry.BaseEntry.#ctor(System.Reflection.Assembly,System.String,System.String,System.Reflection.Assembly)">
            <summary>
            所有配置条目的基类
            </summary>
        </member>
        <member name="M:JmcModLib.Config.Entry.BaseEntry.GetKey(System.Type,System.String)">
            <summary>
            通过 DeclaringType 和 Name 生成唯一 Key（当前asm下唯一）
            </summary>
            <param name="declaringType">变量所在的类的类型</param>
            <param name="Name">变量的名称</param>
            <returns>返回一个形如{declaringType.FullName}.{Name}的唯一Key</returns>
        </member>
        <member name="T:JmcModLib.Config.Entry.ButtonEntry">
            <summary>
            Button 类型的配置项条目
            </summary>
        </member>
        <member name="M:JmcModLib.Config.Entry.ButtonEntry.#ctor(System.Reflection.Assembly,System.Action,System.String,System.String,System.Reflection.Assembly)">
            <summary>
            Action 版本用于手动构建按钮
            </summary>
        </member>
        <member name="T:JmcModLib.Config.Entry.ConfigEntry">
            <summary>
            承载配置信息的类。
            </summary>
        </member>
        <member name="M:JmcModLib.Config.Entry.ConfigEntry.#ctor(System.Reflection.Assembly,System.String,System.String,System.Reflection.Assembly)">
            <summary>
            承载配置信息的类。
            </summary>
        </member>
        <member name="P:JmcModLib.Config.Entry.ConfigEntry.LogicalType">
            <summary>
            数据的原类型，比如传入enum -> string中的enum，若不会额外转换，直接返回TargetType。
            </summary>
        </member>
        <member name="P:JmcModLib.Config.Entry.ConfigEntry.UIType">
            <summary>
            存储的实际类型，比如将enum存为string，则返回string
            </summary>
        </member>
        <member name="M:JmcModLib.Config.Entry.ConfigEntry.SyncFromData">
            <summary>
            通过Getter获取当前值并保存到文件
            </summary>
        </member>
        <member name="P:JmcModLib.Config.Entry.ConfigEntry`1.LogicalType">
            <summary>
            数据的原类型，比如传入enum -> string中的enum，若不会额外转换，直接返回TargetType。
            </summary>
        </member>
        <member name="P:JmcModLib.Config.Entry.ConfigEntry`1.UIType">
            <summary>
            存储的实际类型，比如将enum存为string，则返回string
            </summary>
        </member>
        <member name="P:JmcModLib.Config.Entry.ConfigEntry`1.DefaultValue">
            <summary>
            字段/属性最初的默认值，用于 Reset。
            </summary>
        </member>
        <member name="M:JmcModLib.Config.Entry.ConfigEntry`1.TraitAccessors(JmcModLib.Reflection.MemberAccessor,JmcModLib.Reflection.MethodAccessor)">
            <summary>
            从 MemberAccessor 和 MethodAccessor 萃取出 getter、setter 和 change 方法，并检查合法性。
            </summary>
        </member>
        <member name="M:JmcModLib.Config.Entry.ConfigEntry`1.SyncFromFile">
            <summary>
            同步某一个配置项
            </summary>
        </member>
        <member name="M:JmcModLib.Config.Entry.ConfigEntry`1.SyncFromData">
            <summary>
            从getter获取当前值并保存到文件，一般用于Entry销毁时对比使用，以防子MOD内部直接修改了配置的值但未持久化
            </summary>
        </member>
        <member name="T:JmcModLib.Config.Storage.IConfigStorage">
            <summary>
            配置存储接口
            </summary>
        </member>
        <member name="M:JmcModLib.Config.Storage.IConfigStorage.GetFileName(System.Reflection.Assembly)">
            <summary>
            获取文件名
            </summary>
        </member>
        <member name="M:JmcModLib.Config.Storage.IConfigStorage.Save(System.String,System.String,System.Object,System.Reflection.Assembly)">
            <summary>
            根据 key 和 group 保存配置值
            </summary>
        </member>
        <member name="M:JmcModLib.Config.Storage.IConfigStorage.TryLoad(System.String,System.String,System.Type,System.Object@,System.Reflection.Assembly)">
            <summary>
            保存配置值
            </summary>
            <param name="key">配置项的key</param>
            <param name="group">配置项的组</param>
            <param name="type">值的类型</param>
            <param name="value">输出的值</param>
            <param name="asm">相关的程序集</param>
            <returns>是否成功加载配置</returns>
        </member>
        <member name="M:JmcModLib.Config.Storage.IConfigStorage.Exists(System.Reflection.Assembly)">
            <summary>
            是否存在assembly对应的配置文件
            </summary>
        </member>
        <member name="M:JmcModLib.Config.Storage.IConfigStorage.Flush(System.Reflection.Assembly)">
            <summary>
            真实地将缓存写入存储介质
            </summary>
        </member>
        <member name="T:JmcModLib.Config.Storage.NewtonsoftConfigStorage">
            <summary>
            以 Newtonsoft.Json 作为序列化工具的配置存储实现
            </summary>
        </member>
        <member name="M:JmcModLib.Config.Storage.NewtonsoftConfigStorage.#ctor(System.String)">
            <summary>
            初始化一个 NewtonsoftConfigStorage 实例
            </summary>
            <param name="rootFolder">根目录</param>
        </member>
        <member name="M:JmcModLib.Config.Storage.NewtonsoftConfigStorage.GetFileName(System.Reflection.Assembly)">
            <summary>
            获取文件名
            </summary>
        </member>
        <member name="M:JmcModLib.Config.Storage.NewtonsoftConfigStorage.GetFilePath(System.Reflection.Assembly)">
            <summary>
            获得指定程序集对应的配置文件路径
            </summary>
        </member>
        <member name="M:JmcModLib.Config.Storage.NewtonsoftConfigStorage.Exists(System.Reflection.Assembly)">
            <summary>
            是否存在assembly对应的配置文件
            </summary>
            <param name="asm">默认则为调用者</param>
            <returns>返回结果对应的bool</returns>
        </member>
        <member name="M:JmcModLib.Config.Storage.NewtonsoftConfigStorage.TryLoad(System.String,System.String,System.Type,System.Object@,System.Reflection.Assembly)">
            <summary>
            尝试读取配置项
            </summary>
            <param name="key">json文件中的key</param>
            <param name="group">配置项所属的组名</param>
            <param name="type">期望的值类型</param>
            <param name="value">返回的配置项值</param>
            <param name="asm">调用的程序集，默认是调用者</param>
            <returns>如果加载成功，则返回true</returns>
        </member>
        <member name="M:JmcModLib.Config.Storage.NewtonsoftConfigStorage.Save(System.String,System.String,System.Object,System.Reflection.Assembly)">
            <summary>
            保存配置项到缓存
            </summary>
            <param name="key">json文件中的key</param>
            <param name="group">配置项所属的组名</param>
            <param name="value">返回的配置项值</param>
            <param name="asm">调用的程序集，默认是调用者</param>
        </member>
        <member name="M:JmcModLib.Config.Storage.NewtonsoftConfigStorage.Flush(System.Reflection.Assembly)">
            <summary>
            真正将缓存写回文件
            </summary>
            <param name="asm">指定asm，默认为调用者</param>
        </member>
        <member name="M:JmcModLib.Config.UI.ConfigUIManager.Register(System.Reflection.Assembly)">
            <summary>
            若ASM存在条目，广播此ASM
            </summary>
        </member>
        <member name="M:JmcModLib.Config.UI.CustomHotkey.CustomHotkeyHelper.TryInit">
            <summary>
            尝试初始化
            </summary>
            <remarks>该方法需要首先调用，用来缓存一些反射用的变量</remarks>
        </member>
        <member name="M:JmcModLib.Config.UI.CustomHotkey.CustomHotkeyHelper.AddNewHotkey(System.String,System.String,UnityEngine.KeyCode,System.String)">
            <summary>
            添加新的自定义热键
            </summary>
            <param name="saveName">保存的热键名</param>
            <param name="defaultHotkey">默认热键值</param>
            <param name="showName">显示的热键名</param>
        </member>
        <member name="M:JmcModLib.Config.UI.CustomHotkey.CustomHotkeyHelper.RemoveHotkey(System.String,System.String)">
            <summary>
            移除自定义热键
            </summary>
            <param name="saveName">保存的热键名</param>
        </member>
        <member name="M:JmcModLib.Config.UI.CustomHotkey.CustomHotkeyHelper.GetHotkey(System.String,System.String)">
            <summary>
            获取自定义按键值
            </summary>
            <param name="saveName">保存的热键名</param>
        </member>
        <member name="M:JmcModLib.Config.UI.CustomHotkey.CustomHotkeyHelper.TryAddEvent2OnCustomHotkeyChangedEvent(System.String,System.Action)">
            <summary>
            尝试添加当热键修改时的回调
            </summary>
            <remarks>多次调用并不会重复添加回调</remarks>
        </member>
        <member name="M:JmcModLib.Config.UI.CustomHotkey.CustomHotkeyHelper.RemoveEvent2OnCustomHotkeyChangedEvent(System.String,System.Action)">
            <summary>
            移除当热键修改时的回调
            </summary>
        </member>
        <member name="M:JmcModLib.Config.UI.CustomHotkey.CustomHotkeyLinker.IsRegistered(System.Reflection.Assembly)">
            <summary>
            判断有没有注册过 Asm到Linker
            </summary>
        </member>
        <member name="M:JmcModLib.Config.UI.CustomHotkey.CustomHotkeyLinker.IsInitialized(System.Reflection.Assembly)">
            <summary>
            判断有没有将 ASM注册到 ModSetting UI 并且已经初始化完成。
            </summary>
        </member>
        <member name="M:JmcModLib.Config.UI.CustomHotkey.CustomHotkeyLinker.BuildMeta(System.Reflection.Assembly)">
            <summary>
            当一个ASM配置扫描完毕，注册元信息
            </summary>
            <param name="asm"></param>
        </member>
        <member name="M:JmcModLib.Config.UI.CustomHotkey.CustomHotkeyLinker.InitMod(System.Reflection.Assembly)">
            <summary>
            将指定程序集的 ModSetting 注册到 ModSetting UI。
            </summary>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingAPI.Init(Duckov.Modding.ModInfo)">
            <summary>
            初始化API
            </summary>
            <param name="modInfo">mod信息</param>
            <returns>是否成功初始化</returns>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingAPI.AddDropdownList(Duckov.Modding.ModInfo,System.String,System.String,System.Collections.Generic.List{System.String},System.String,System.Action{System.String})">
            <summary>
            添加一个下拉列表控件
            </summary>
            <param name="modInfo">对应的MOD</param>
            <param name="key">控件key</param>
            <param name="description">描述文本</param>
            <param name="options">选项列表</param>
            <param name="defaultValue">当前值</param>
            <param name="onValueChange">值改变时的回调函数</param>
            <returns></returns>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingAPI.AddSlider(Duckov.Modding.ModInfo,System.String,System.String,System.Single,UnityEngine.Vector2,System.Action{System.Single},System.Int32,System.Int32)">
            <summary>
            添加一个浮点数滑块控件
            </summary>
            <param name="modInfo">对应的MOD</param>
            <param name="key">控件key</param>
            <param name="description">描述文本</param>
            <param name="defaultValue">当前值</param>
            <param name="sliderRange">滑块范围</param>
            <param name="onValueChange">值改变时的回调函数</param>
            <param name="decimalPlaces">小数位数</param>
            <param name="characterLimit">输入字符限制</param>
            <returns></returns>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingAPI.AddSlider(Duckov.Modding.ModInfo,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Action{System.Int32},System.Int32)">
            <summary>
            添加一个整数滑块控件
            </summary>
            <param name="modInfo">对应的MOD</param>
            <param name="key">控件key</param>
            <param name="description">描述文本</param>
            <param name="defaultValue">当前值</param>
            <param name="minValue">最小值</param>
            <param name="maxValue">最大值</param>
            <param name="onValueChange">值改变时的回调函数</param>
            <param name="characterLimit">输入字符限制</param>
            <returns></returns>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingAPI.AddToggle(Duckov.Modding.ModInfo,System.String,System.String,System.Boolean,System.Action{System.Boolean})">
            <summary>
            添加一个开关控件
            </summary>
            <param name="modInfo">对应的MOD</param>
            <param name="key">控件key</param>
            <param name="description">描述文本</param>
            <param name="enable">当前值</param>
            <param name="onValueChange">值改变时的回调函数</param>
            <returns></returns>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingAPI.AddKeybinding(Duckov.Modding.ModInfo,System.String,System.String,UnityEngine.KeyCode,System.Action{UnityEngine.KeyCode})">
            <summary>
            添加一个按键绑定控件，默认值None
            </summary>
            <param name="modInfo">对应的MOD</param>
            <param name="key">控件key</param>
            <param name="description">描述文本</param>
            <param name="keyCode">当前值</param>
            <param name="onValueChange">值改变时的回调函数</param>
            <returns></returns>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingAPI.AddKeybinding(Duckov.Modding.ModInfo,System.String,System.String,UnityEngine.KeyCode,UnityEngine.KeyCode,System.Action{UnityEngine.KeyCode})">
            <summary>
            添加一个带默认值的按键绑定控件
            </summary>
            <param name="modInfo">对应的MOD</param>
            <param name="key">控件key</param>
            <param name="description">描述文本</param>
            <param name="keyCode">当前值</param>
            <param name="defaultKeyCode">默认值</param>
            <param name="onValueChange">值改变时的回调函数</param>
            <returns></returns>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingAPI.AddInput(Duckov.Modding.ModInfo,System.String,System.String,System.String,System.Int32,System.Action{System.String})">
            <summary>
            添加一个输入框控件
            </summary>
            <param name="modInfo">对应的MOD</param>
            <param name="key">控件key</param>
            <param name="description">描述文本</param>
            <param name="defaultValue">当前值</param>
            <param name="characterLimit">输入字符限制</param>
            <param name="onValueChange">值改变时的回调函数</param>
            <returns></returns>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingAPI.AddButton(Duckov.Modding.ModInfo,System.String,System.String,System.String,System.Action)">
            <summary>
            添加一个按钮控件
            </summary>
            <param name="modInfo">对应的MOD</param>
            <param name="key">控件key</param>
            <param name="description">描述文本</param>
            <param name="buttonText">按钮文本</param>
            <param name="onClickButton">点击时的回调函数</param>
            <returns></returns>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingAPI.AddGroup(Duckov.Modding.ModInfo,System.String,System.String,System.Collections.Generic.List{System.String},System.Single,System.Boolean,System.Boolean)">
            <summary>
            添加一个分组控件，用于将多个控件组织在一起
            </summary>
            <param name="modInfo">对应的MOD</param>
            <param name="key">控件key</param>
            <param name="description">描述文本</param>
            <param name="keys">包含的控件键列表(暂不支持嵌套Group)</param>
            <param name="scale">缩放比例(相对于mod标题)，最大0.9f</param>
            <param name="topInsert">是否插入到顶部</param>
            <param name="open">是否默认展开</param>
            <returns></returns>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingAPI.GetValue``1(Duckov.Modding.ModInfo,System.String,System.Action{``0})">
            <summary>
            获取指定key的配置值
            </summary>
            <param name="modInfo">对应的MOD</param>
            <param name="key">控件key</param>
            <param name="callback">回调函数返回结果</param>
            <typeparam name="T">值类型</typeparam>
            <returns></returns>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingAPI.SetValue``1(Duckov.Modding.ModInfo,System.String,``0,System.Action{System.Boolean})">
            <summary>
            设置指定key的配置值，单方面通知控件更新
            </summary>
            <param name="modInfo">对应的MOD</param>
            <param name="key">控件key</param>
            <param name="value">设置值</param>
            <param name="callback">回调函数返回是否成功</param>
            <typeparam name="T">值类型</typeparam>
            <returns></returns>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingAPI.HasConfig(Duckov.Modding.ModInfo)">
            <summary>
            检查是否存在此mod的配置文件
            </summary>
            <returns></returns>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingAPI.GetSavedValue``1(Duckov.Modding.ModInfo,System.String,``0@)">
            <summary>
            获取已保存的配置值
            </summary>
            <param name="modInfo">对应的MOD</param>
            <param name="key">控件key</param>
            <param name="value">保存的值</param>
            <typeparam name="T">值类型</typeparam>
            <returns></returns>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingAPI.RemoveUI(Duckov.Modding.ModInfo,System.String,System.Action{System.Boolean})">
            <summary>
            移除指定键对应的UI控件
            </summary>
            <param name="modInfo">对应的MOD</param>
            <param name="key">控件key</param>
            <param name="callback">回调函数返回操作结果</param>
            <returns></returns>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingAPI.RemoveMod(Duckov.Modding.ModInfo,System.Action{System.Boolean})">
            <summary>
            移除整个模组的UI配置,当禁用此mod时，ModSetting会自动移除相对应的UI，一般来说不需要调用，除非想要主动移除mod所有UI
            </summary>
            <param name="modInfo">对应的MOD</param>
            <param name="callback">回调函数返回操作结果</param>
            <returns></returns>
        </member>
        <member name="T:JmcModLib.Config.UI.ModSetting.ModSettingLinker">
            <summary>
            负责将 DuckSort 的 ModConfig 注册到 ModSetting。
            </summary>
            <remarks>
            两个路径，当此MOD与子MOD在Setting上线前注册配置，在Setting上线时会直接从UIManager处获取Entry并构建所有，
            当Setting上线后才出现配置，则UIManager处读一条这里构建一条，并在扫描结束后构建元信息
            </remarks>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingLinker.IsRegistered(System.Reflection.Assembly)">
            <summary>
            判断有没有注册过 Asm到Linker
            </summary>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingLinker.IsInitialized(System.Reflection.Assembly)">
            <summary>
            判断有没有将 ASM注册到 ModSetting UI 并且已经初始化完成。
            </summary>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingLinker.BuildMeta(System.Reflection.Assembly)">
            <summary>
            当一个ASM配置扫描完毕，注册元信息
            </summary>
            <param name="asm"></param>
        </member>
        <member name="M:JmcModLib.Config.UI.ModSetting.ModSettingLinker.InitMod(System.Reflection.Assembly)">
            <summary>
            将指定程序集的 ModSetting 注册到 ModSetting UI。
            </summary>
        </member>
        <member name="T:JmcModLib.Config.UI.PendingUIEntry`2">
            <summary>
            一个用于存储待处理 UI 配置项的类。
            </summary>
        </member>
        <member name="T:JmcModLib.Config.UI.UIBaseAttribute">
            <summary>
            整体标签基类
            </summary>
        </member>
        <member name="T:JmcModLib.Config.UI.UIButtonAttribute">
            <summary>
            一个按钮属性
            </summary>
            <remarks>
            只能绑定在静态无参无返回值构造上
            </remarks>
            <param name="description"></param>
            <param name="buttonText"></param>
            <param name="group"></param>
        </member>
        <member name="M:JmcModLib.Config.UI.UIButtonAttribute.#ctor(System.String,System.String,System.String)">
            <summary>
            一个按钮属性
            </summary>
            <remarks>
            只能绑定在静态无参无返回值构造上
            </remarks>
            <param name="description"></param>
            <param name="buttonText"></param>
            <param name="group"></param>
        </member>
        <member name="M:JmcModLib.Config.UI.UIButtonAttribute.IsValidMethod(System.Reflection.MethodInfo,System.Nullable{JmcModLib.Utils.LogLevel}@,System.String@)">
            <summary>
            检查 MethodInfo 是否满足 UIButtonAttribute 的要求（静态、void、无参）
            </summary>
            <param name="method">要检查的方法</param>
            <param name="level"></param>
            <returns>如果方法合法返回 true，否则返回 false</returns>
            <param name="errorMessage">如果验证失败，返回错误描述</param>
        </member>
        <member name="T:JmcModLib.Config.UI.UIConfigAttribute">
            <summary>
            需要维护数据的 ui 配置属性基类。
            </summary>
        </member>
        <member name="T:JmcModLib.Config.UI.UIConfigAttribute`1">
            <summary>
            用于标记具有某个类型约束的基类属性
            </summary>
        </member>
        <member name="T:JmcModLib.Config.UI.UISliderAttribute`1">
            <summary>
            具有某个类型的滑动条
            </summary>
        </member>
        <member name="M:JmcModLib.Config.UI.UISliderAttribute`1.#ctor(`0,`0,System.Int32)">
            <summary>
            具有某个类型的滑动条
            </summary>
        </member>
        <member name="T:JmcModLib.Config.UI.UIFloatSliderAttribute">
            <summary>
            float 滑动条属性
            </summary>
            <remarks>
            float 滑动条属性
            </remarks>
            <param name="min">滑动下限</param>
            <param name="max">滑动上限</param>
            <param name="decimalPlaces">小数位数</param>
            <param name="characterLimit">输入字符限制</param>
        </member>
        <member name="M:JmcModLib.Config.UI.UIFloatSliderAttribute.#ctor(System.Single,System.Single,System.Int32,System.Int32)">
            <summary>
            float 滑动条属性
            </summary>
            <remarks>
            float 滑动条属性
            </remarks>
            <param name="min">滑动下限</param>
            <param name="max">滑动上限</param>
            <param name="decimalPlaces">小数位数</param>
            <param name="characterLimit">输入字符限制</param>
        </member>
        <member name="T:JmcModLib.Config.UI.UIIntSliderAttribute">
            <summary>
            Int 滑动条属性
            </summary>
            <remarks>
            Int 滑动条属性
            </remarks>
            <param name="min">滑动下限</param>
            <param name="max">滑动上限</param>
            <param name="characterLimit">输入字符限制</param>
        </member>
        <member name="M:JmcModLib.Config.UI.UIIntSliderAttribute.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Int 滑动条属性
            </summary>
            <remarks>
            Int 滑动条属性
            </remarks>
            <param name="min">滑动下限</param>
            <param name="max">滑动上限</param>
            <param name="characterLimit">输入字符限制</param>
        </member>
        <member name="T:JmcModLib.Config.UI.UIToggleAttribute">
            <summary>
            开关属性
            </summary>
        </member>
        <member name="T:JmcModLib.Config.UI.UIKeyBindAttribute">
            <summary>
            绑定按键属性
            </summary>
        </member>
        <member name="T:JmcModLib.Config.UI.UIInputAttribute">
            <summary>
            输入框属性
            </summary>
            <remarks>
            初始化一个输入框属性
            </remarks>
            <param name="characterLimit">输入字符限制</param>
        </member>
        <member name="M:JmcModLib.Config.UI.UIInputAttribute.#ctor(System.Int32)">
            <summary>
            输入框属性
            </summary>
            <remarks>
            初始化一个输入框属性
            </remarks>
            <param name="characterLimit">输入字符限制</param>
        </member>
        <member name="T:JmcModLib.Config.UI.UINeedCovertAttribute">
            <summary>
            需要转换的 UI 配置属性基类。
            </summary>
        </member>
        <member name="T:JmcModLib.Config.UI.UIConverterAttribute`1">
            <summary>
            强类型的需要转换的 UI 配置属性基类。
            </summary>
            <typeparam name="T"> 转换到的目标类型 </typeparam>
        </member>
        <member name="M:JmcModLib.Config.UI.UIConverterAttribute`1.ToUI(System.Object)">
            <summary>
            将原始数据转换为UI层/存储层需要的数据
            </summary>
        </member>
        <member name="M:JmcModLib.Config.UI.UIConverterAttribute`1.FromUI(`0,System.Type)">
            <summary>
            从UI层/存储层转回原始数据
            </summary>
        </member>
        <member name="T:JmcModLib.Config.UI.UIDropdownAttribute">
            <summary>
            添加一个下拉框属性，仅支持枚举类型
            </summary>
            <param name="exclude">要排除的枚举选项，字符串表示，不检查是否存在此枚举项</param>
        </member>
        <member name="M:JmcModLib.Config.UI.UIDropdownAttribute.#ctor(System.String[])">
            <summary>
            添加一个下拉框属性，仅支持枚举类型
            </summary>
            <param name="exclude">要排除的枚举选项，字符串表示，不检查是否存在此枚举项</param>
        </member>
        <member name="M:JmcModLib.Config.UI.UIDropdownAttribute.ToUI(System.Object)">
            <summary>
            从原始数据转UI数据（Enum转字符串）
            </summary>
            <param name="logicalValue"></param>
            <returns></returns>
        </member>
        <member name="M:JmcModLib.Config.UI.UIDropdownAttribute.FromUI(System.String,System.Type)">
            <summary>
            从UI层/存储层转回原始数据
            </summary>
        </member>
        <member name="T:JmcModLib.Core.AttributeRouter.AttributeRouter">
            <summary>
            AttributeRouter: 按 Attribute 类型把扫描到的访问器分发到对应 Handler。
            线程安全，支持按 Assembly 扫描与撤销（若 Handler 支持）。
            </summary>
        </member>
        <member name="E:JmcModLib.Core.AttributeRouter.AttributeRouter.OnRegistered">
            <summary>
            当一个 MOD 完成注册后触发。
            参数：Assembly（唯一标识MOD）（该MOD元信息）
            </summary>
        </member>
        <member name="E:JmcModLib.Core.AttributeRouter.AttributeRouter.OnUnRegistered">
            <summary>
            反注册 MOD 时触发。
            </summary>
        </member>
        <member name="M:JmcModLib.Core.AttributeRouter.AttributeRouter.RegisterHandler``1(JmcModLib.Core.AttributeRouter.IAttributeHandler)">
            <summary>
            注册一个 handler 用于处理指定 Attribute 类型。重复注册会追加。
            </summary>
        </member>
        <member name="M:JmcModLib.Core.AttributeRouter.AttributeRouter.RegisterHandler``1(System.Action{System.Reflection.Assembly,JmcModLib.Reflection.ReflectionAccessorBase,``0})">
            <summary>
            注册一个基于委托的简单 handler。会被包装成 SimpleAttributeHandler。
            </summary>
        </member>
        <member name="M:JmcModLib.Core.AttributeRouter.AttributeRouter.UnregisterHandler(JmcModLib.Core.AttributeRouter.IAttributeHandler)">
            <summary>
            取消注册 handler（移除该 handler 对应的所有映射）
            </summary>
        </member>
        <member name="M:JmcModLib.Core.AttributeRouter.AttributeRouter.ScanAssembly(System.Reflection.Assembly)">
            <summary>
            扫描 Assembly 中的所有 Type / Method / Member并分发 attribute。
            如果已扫描过会跳过（幂等）。
            </summary>
        </member>
        <member name="M:JmcModLib.Core.AttributeRouter.AttributeRouter.UnscanAssembly(System.Reflection.Assembly)">
            <summary>
            撤销某个 Assembly 的所有 Handler 注册效果（如果 Handler 实现了 IAttributeHandler.Unregister，则会调用）。
            最后从已扫描集合中移除记录。
            </summary>
        </member>
        <member name="T:JmcModLib.Core.AttributeRouter.SimpleAttributeHandler`1">
            <summary>
            简单的基于泛型 Attribute 的实现，使用委托包装 Handle，
            并且默认不支持 Unregister。
            </summary>
        </member>
        <member name="T:JmcModLib.Core.AttributeRouter.IAttributeHandler">
            <summary>
            Handler 的统一接口。
            - Handle：当 Attribute 被发现时调用。
            - Unregister：可选，若实现则在 Assembly Unscan 时被调用，参数为 asm 与被处理过的 accessor 列表。
            </summary>
        </member>
        <member name="T:JmcModLib.Core.ModRegistry">
            <summary>
            MOD 注册管理器。
            使用前应该先注册 MOD 信息。
            <example>
            示例：
            <code>
            // 简单注册（自动完成）
            ModRegistry.Register(VersionInfo.ModInfo, "MyMod", "1.0.0");
            
            // 链式注册（手动完成）
            ModRegistry.Register(true, VersionInfo.ModInfo, "MyMod", "1.0.0")
                       .RegisterL10n("Lang")
                       .RegisterLogger(LogLevel.Debug)
                       .Done();
            </code>
            </example>
            </summary>
        </member>
        <member name="E:JmcModLib.Core.ModRegistry.OnRegistered">
            <summary>
            当一个 MOD 完成注册后触发。
            参数：Assembly（唯一标识MOD）（该MOD元信息）
            </summary>
        </member>
        <member name="E:JmcModLib.Core.ModRegistry.OnUnRegistered">
            <summary>
            反注册 MOD 时触发。
            </summary>
        </member>
        <member name="M:JmcModLib.Core.ModRegistry.Register(Duckov.Modding.ModInfo,System.String,System.String,System.Reflection.Assembly)">
            <summary>
            调用Register注册元信息并将其他模块按初始化注册
            </summary>
            <remarks>
            <para>至少需要在OnAfterSetup及以后（不能在OnEnable及以前）调用，否则info信息未初始化不可用</para>
            <para>当需要手动创建带组的UI条目或需要手动指定某些模块的初始化参数，需要阻塞注册以进行链式调用，请使用重载Register(bool deferredCompletion, ...)</para>
            </remarks>
            <param name="info"> MOD的info信息，可以在OnAfterSetup及以后取得，OnEnable阶段该值未初始化，不可用 </param>
            <param name="name">MOD的名称，留空将在modinfo中取得，若也为空将在assembly中取得</param>
            <param name="version">MOD的版本号，留空或填null则会在modinfo中取得，若也为空将在assembly中取得</param>
            <param name="assembly">程序集，留空自动获取</param>
        </member>
        <member name="M:JmcModLib.Core.ModRegistry.Register(System.Boolean,Duckov.Modding.ModInfo,System.String,System.String,System.Reflection.Assembly)">
            <summary>
            调用Register注册元信息并阻塞自动注册以进行链式调用
            </summary>
            <remarks>
            <para>至少需要在OnAfterSetup及以后（不能在OnEnable及以前）调用，否则info信息未初始化不可用</para>
            <para>当需要手动创建带组的UI条目或需要手动指定某些模块的初始化参数，调用此重载版本，请使用重载Register(Modinfo info, ...)</para>
            </remarks>
            <param name="deferredCompletion"> 是否阻塞自动注册 </param>
            <param name="info"> MOD的info信息，可以在OnAfterSetup及以后取得，OnEnable阶段该值未初始化，不可用 </param>
            <param name="name">MOD的名称，留空将在modinfo中取得，若也为空将在assembly中取得</param>
            <param name="version">MOD的版本号，留空或填null则会被默认置为1.0.0</param>
            <param name="assembly"></param>
            <returns> 若已注册或未阻塞（deferredCompletion的值为false）返回空，否则返回一个链式构造器，构造完成后调用Done即可 </returns>
        </member>
        <member name="M:JmcModLib.Core.ModRegistry.IsRegistered(System.Reflection.Assembly)">
            <summary>
            判断是否已注册
            </summary>
        </member>
        <member name="M:JmcModLib.Core.ModRegistry.UnRegister(System.Reflection.Assembly)">
            <summary>
            反注册程序集的MOD信息，留空则反注册调用者的程序集
            </summary>
            <remarks> 原本的API，现已internal </remarks>
        </member>
        <member name="M:JmcModLib.Core.ModRegistry.GetModInfo(System.Reflection.Assembly)">
            <summary>
            获取程序集的MOD信息，留空则返回调用者的信息
            </summary>
        </member>
        <member name="M:JmcModLib.Core.ModRegistry.GetTag(System.Reflection.Assembly)">
            <summary>
            获取由程序集Mod名与版本号拼接成的标签，留空则返回调用者的Tag
            </summary>
            <returns> 返回$"[{info.Name} v{info.Version}]"，若未注册，则由assembly的Name与Version拼接 </returns>
        </member>
        <member name="T:JmcModLib.Core.ModRegistry.Modinfo">
            <summary>
            Mod的元信息
            </summary>
            <param name="Info">Mod的详细信息</param>
            <param name="Name">Mod名</param>
            <param name="Version">Mod版本号</param>
        </member>
        <member name="M:JmcModLib.Core.ModRegistry.Modinfo.#ctor(Duckov.Modding.ModInfo,System.String,System.String)">
            <summary>
            Mod的元信息
            </summary>
            <param name="Info">Mod的详细信息</param>
            <param name="Name">Mod名</param>
            <param name="Version">Mod版本号</param>
        </member>
        <member name="P:JmcModLib.Core.ModRegistry.Modinfo.Info">
            <summary>Mod的详细信息</summary>
        </member>
        <member name="P:JmcModLib.Core.ModRegistry.Modinfo.Name">
            <summary>Mod名</summary>
        </member>
        <member name="P:JmcModLib.Core.ModRegistry.Modinfo.Version">
            <summary>Mod版本号</summary>
        </member>
        <member name="T:JmcModLib.Core.RegistryBuilder">
            <summary>
            用于支持链式调用注册的构建器，以注册需要手动特殊指定的模块，仅可通过 ModRegistry.Register(bool deferredCompletion, ...) 获取。
            </summary>
            <remarks>
            结束后调用 Done() 完成注册，否则不会触发注册完成事件。
            </remarks>
        </member>
        <member name="M:JmcModLib.Core.RegistryBuilder.RegisterL10n(System.String,UnityEngine.SystemLanguage)">
            <summary>
            注册当前程序集的本地化文件夹路径（例如 "Mods/MyMod/Lang"）。
            若找不到指定的备用语言对应的文件，会将指定文件夹的第一个 `.csv` 文件作为备用语言文件。
            </summary>
            <param name="langFolderRelative">存放本地化csv的相对路径，默认为“Lang”</param>
            <param name="fallbackLang">指定某语言文件不存在时的备份语言，默认为英语</param>
            <returns> 返回当前的RegsistryBuilder实例以支持链式调用 </returns>
        </member>
        <member name="M:JmcModLib.Core.RegistryBuilder.RegisterLogger(JmcModLib.Utils.LogLevel,JmcModLib.Utils.LogFormatFlags,JmcModLib.Utils.LogConfigUIFlags)">
            <summary>
            注册当前日志库的日志打印设置。
            </summary>
            <param name="level"> 默认的最低打印等级 </param>
            <param name="tagFlags"> 默认显示的标签 </param>
            <param name="uIFlags"> 默认的自动添加UI，默认添加日志最低打印等级列表与各个标签的开关并集成到一个组里 </param>
            <returns> 返回当前的RegsistryBuilder实例以支持链式调用 </returns>
        </member>
        <member name="M:JmcModLib.Core.RegistryBuilder.RegisterButton(System.String@,System.String,System.Action,System.String,System.String,System.Reflection.Assembly)">
            <summary>
            注册一个按钮，相关文本将自动调用本地化文件
            </summary>
            <param name="key">返回按钮的Key</param>
            <param name="description"> 按钮的描述文本 </param>
            <param name="action"> 按钮的行为 </param>
            <param name="buttonText"> 按钮上的文本 </param>
            <param name="group"> 按钮所在的组，留空为默认 </param>
            <param name="l10nAsm"> 本地化指定的程序集，留空则与主程序集相同 </param>
        </member>
        <member name="M:JmcModLib.Core.RegistryBuilder.RegisterConfig``1(System.String@,System.String,System.Func{``0},System.Action{``0},System.String,System.Reflection.Assembly)">
            <summary>
            仅注册配置项，不绑定任何UI，仅用于持久化
            </summary>
            <remarks> 可为实例对象，但应当自行维护生命周期，保证自注册至MOD卸载期间不被销毁。 </remarks>
            <typeparam name="T"> 注册的值的类型 </typeparam>
            <param name="key"> 返回配置项的Key，可以通过GetValue/SetValue函数查询系统内的值 </param>
            <param name="displayName"> 用作在持久化文本中的条目名称 </param>
            <param name="getter"> 维护的值的getter，在设置初始值以及卸载阶段调用一次以同步文件 </param>
            <param name="setter"> 维护的值的setter，用户若需要在代码中改值，最好使用GetValue(key)，但直接修改自己的值也会在最后保存文件时同步保存，只是不能同步UI </param>
            <param name="group"> 值所在的组，若不需要分组则留空 </param>
            <param name="l10nAsm"> 本地化指定的程序集，留空则与主程序集相同 </param>
        </member>
        <member name="M:JmcModLib.Core.RegistryBuilder.RegisterConfig``1(System.String@,JmcModLib.Config.UI.UIConfigAttribute{``0},System.String,System.Func{``0},System.Action{``0},System.String,System.Action{``0},System.Reflection.Assembly)">
            <summary>
            通过getter/setter 注册一个配置项。
            </summary>
            <remarks> 可为实例对象，但应当自行维护生命周期，保证自注册至MOD卸载期间不被销毁。 </remarks>
            <typeparam name="T"> 注册的值的类型 </typeparam>
            <param name="key"> 返回配置项的Key，可以通过GetValue/SetValue函数查询系统内的值 </param>
            <param name="uiAttr"> 需要注册UI的Attribute，相关文本将自动调用本地化文件 </param>
            <param name="displayName"> 显示文本，用于保存以及显示在UI系统里 </param>
            <param name="getter"> 维护的值的getter，在设置初始值以及卸载阶段调用一次以同步文件 </param>
            <param name="setter"> 维护的值的setter，用户若需要在代码中改值，最好使用GetValue(key)，但直接修改自己的值也会在最后保存文件时同步保存，只是不能同步UI </param>
            <param name="group"> 值所在的组，若不需要分组则留空 </param>
            <param name="action"> 若需注册UI且需要额外的回调函数，则填入，若不需要则留空，此处禁止调用ConfigManager的SetVal </param>
            <param name="l10nAsm"> 本地化指定的程序集，留空则与主程序集相同 </param>
        </member>
        <member name="M:JmcModLib.Core.RegistryBuilder.RegisterConfig``1(System.String@,JmcModLib.Config.UI.UIDropdownAttribute,System.String,System.Func{``0},System.Action{``0},System.String,System.Action{``0},System.Reflection.Assembly)">
            <summary>
            通过枚举值注册一个下拉列表，将自动从枚举值生成下拉列表。
            </summary>
            <typeparam name="TEnum"> 用于配置的枚举类型 </typeparam>
            <param name="key"> 返回配置项的Key，可以通过GetValue/SetValue函数查询系统内的值 </param>
            <param name="uiAttr"> 需要注册UI的Attribute，相关文本将自动调用本地化文件 </param>
            <param name="displayName"> 显示文本，用于保存以及显示在UI系统里 </param>
            <param name="getter"> 维护的值的getter，在设置初始值以及卸载阶段调用一次以同步文件 </param>
            <param name="setter"> 维护的值的setter，用户若需要在代码中改值，最好使用GetValue(key)，但直接修改自己的值也会在最后保存文件时同步保存，只是不能同步UI </param>
            <param name="group"> 值所在的组，若不需要分组则留空 </param>
            <param name="action"> 若需注册UI且需要额外的回调函数，则填入，若不需要则留空，此处禁止调用ConfigManager的SetVal </param>
            <param name="l10nAsm"> 本地化指定的程序集，留空则与主程序集相同 </param>
        </member>
        <member name="M:JmcModLib.Core.RegistryBuilder.RegisterConfig``1(System.String@,JmcModLib.Config.UI.UIConfigAttribute{``0},System.String,``0,System.String,System.Action{``0},System.Reflection.Assembly)">
            <summary>
            直接通过非空值注册一个配置项，由此MOD自行维护该值的生命周期，可通过 GetValue/SetValue 查询修改。
            </summary>
            <typeparam name="T"> 注册的配置项类型 </typeparam>
            <param name="key"> 返回配置项的Key，可以通过GetValue/SetValue函数查询系统内的值 </param>
            <param name="uiAttr"> 需要注册UI的Attribute，相关文本将自动调用本地化文件 </param>
            <param name="displayName"> 显示文本，用于保存以及显示在UI系统里 </param>
            <param name="defaultValue"> 默认值 </param>
            <param name="group"> 值所在的组，若不需要分组则留空 </param>
            <param name="action"> 若需注册UI且需要额外的回调函数，则填入，若不需要则留空，此处禁止调用ConfigManager的SetVal </param>
            <param name="l10nAsm"> 本地化指定的程序集，留空则与主程序集相同 </param>
        </member>
        <member name="M:JmcModLib.Core.RegistryBuilder.RegisterConfig``1(System.String@,JmcModLib.Config.UI.UIDropdownAttribute,System.String,``0,System.String,System.Action{``0},System.Reflection.Assembly)">
            <summary>
            用一个非空枚举值生成下拉列表注册一个配置项，由此MOD自行维护该值的生命周期，可通过 GetValue/SetValue 查询修改。
            </summary>
            <typeparam name="TEnum"> 用于配置的枚举类型 </typeparam>
            <param name="key"> 返回配置项的Key，可以通过GetValue/SetValue函数查询系统内的值 </param>
            <param name="uiAttr"> 需要注册UI的Attribute，相关文本将自动调用本地化文件 </param>
            <param name="displayName"> 显示文本，用于保存以及显示在UI系统里 </param>
            <param name="defaultValue"> 默认枚举值 </param>
            <param name="group"> 值所在的组，若不需要分组则留空 </param>
            <param name="action"> 若需注册UI且需要额外的回调函数，则填入，若不需要则留空，此处禁止调用ConfigManager的SetVal </param>
            <param name="l10nAsm"> 本地化指定的程序集，留空则与主程序集相同 </param>
        </member>
        <member name="M:JmcModLib.Core.RegistryBuilder.RegisterConfig``1(System.String@,JmcModLib.Config.UI.UIConfigAttribute{``0},System.String,System.Linq.Expressions.Expression{System.Func{``0}},System.String,System.Action{``0},System.Reflection.Assembly)">
            <summary>
            通过形如 `() => ClassName.StaticName / () => InstanceName.FieldName` 的表达式注册一个配置项，字段/属性/静态/实例均可。
            </summary>
            <remarks> 可为实例对象，但应当自行维护生命周期，保证自注册至MOD卸载期间不被销毁。 </remarks>
            <typeparam name="T"> 注册的配置项类型 </typeparam>
            <param name="key"> 返回配置项的Key，可以通过GetValue/SetValue函数查询系统内的值 </param>
            <param name="uiAttr"> 需要注册UI的Attribute，相关文本将自动调用本地化文件 </param>
            <param name="displayName"> 显示文本，用于保存以及显示在UI系统里 </param>
            <param name="expr"> 形如 `() => ClassName.StaticName / () => InstanceName.FieldName` 的表达式 </param>
            <param name="group"> 值所在的组，若不需要分组则留空 </param>
            <param name="action"> 若需注册UI且需要额外的回调函数，则填入，若不需要则留空，此处禁止调用ConfigManager的SetVal </param>
            <param name="l10nAsm"> 本地化指定的程序集，留空则与主程序集相同 </param>
            <exception cref="T:System.ArgumentException"> 传递的表达式不合法 </exception>
        </member>
        <member name="M:JmcModLib.Core.RegistryBuilder.RegisterConfig``1(System.String@,JmcModLib.Config.UI.UIDropdownAttribute,System.String,System.Linq.Expressions.Expression{System.Func{``0}},System.String,System.Action{``0},System.Reflection.Assembly)">
            <summary>
            通过形如 `() => ClassName.StaticName / () => InstanceName.FieldName` 的表达式注册一个下拉列表，字段/属性/静态/实例均可。
            </summary>
            <typeparam name="TEnum"> 用于配置的枚举类型 </typeparam>
            <param name="key"> 返回配置项的Key，可以通过GetValue/SetValue函数查询系统内的值 </param>
            <param name="uiAttr"> 需要注册UI的Attribute，相关文本将自动调用本地化文件 </param>
            <param name="displayName"> 显示文本，用于保存以及显示在UI系统里 </param>
            <param name="expr"> 形如 `() => ClassName.StaticName / () => InstanceName.FieldName` 的表达式 </param>
            <param name="group"> 值所在的组，若不需要分组则留空 </param>
            <param name="action"> 若需注册UI且需要额外的回调函数，则填入，若不需要则留空，此处禁止调用ConfigManager的SetVal </param>
            <param name="l10nAsm"> 本地化指定的程序集，留空则与主程序集相同 </param>
        </member>
        <member name="M:JmcModLib.Core.RegistryBuilder.Done">
            <summary>
            结束注册过程，触发注册完成事件（开始自动扫描配置、按默认值初始化未手动初始化的模块），返回void。
            </summary>
        </member>
        <member name="T:JmcModLib.Dependency.ModLinkEvent">
            <summary>
            标记方法是MOD启用时还是禁用时的回调
            </summary>
        </member>
        <member name="F:JmcModLib.Dependency.ModLinkEvent.Activated">
            <summary>标记方法在MOD启用时调用 </summary>
        </member>
        <member name="F:JmcModLib.Dependency.ModLinkEvent.Deactivated">
            <summary>标记方法在MOD禁用时调用 </summary>
        </member>
        <member name="T:JmcModLib.Dependency.ModLinkAttribute">
            <summary>
            标记一个方法在指定MOD启用或禁用时调用
            </summary>
        </member>
        <member name="M:JmcModLib.Dependency.ModLinkAttribute.#ctor(System.String,JmcModLib.Dependency.ModLinkEvent)">
            <summary>
            标记一个方法在指定MOD启用或禁用时调用
            </summary>
        </member>
        <member name="P:JmcModLib.Dependency.ModLinkAttribute.Name">
            <summary>
            查找的MOD名
            </summary>
        </member>
        <member name="P:JmcModLib.Dependency.ModLinkAttribute.Event">
            <summary>
            方法调用的时机
            </summary>
        </member>
        <member name="T:JmcModLib.Dependency.ModLinkAttributeHandler">
            <summary>
            负责解析并注册 [ModLink] 标记的方法，让 ModLinker 正确调度。
            </summary>
        </member>
        <member name="P:JmcModLib.Dependency.ModLinkAttributeHandler.Unregister">
            <summary>
            当整个 Assembly 注销时，Router 会调用这里执行清理
            </summary>
        </member>
        <member name="T:JmcModLib.Dependency.ModLinker">
            <summary>
            当某个 MOD 激活/停用时，执行相关联的操作。
            现代化、线程安全实现。
            </summary>
            <remarks>
            使用[ModLinker(MODNAME, ModLinkEvent.Activated)]等属性注册回调，回调函数必须是静态方法，参数可以是 (ModInfo info, ModBehaviour behaviour)、(ModInfo info) 或无参数，返回值将被忽略。
            </remarks>
        </member>
        <member name="M:JmcModLib.Dependency.ModLinker.Unregister(System.String,System.Reflection.Assembly)">
            <summary>
            移除特定 (modName, asm) 注册。
            </summary>
        </member>
        <member name="M:JmcModLib.Dependency.ModLinker.UnregisterAssembly(System.Reflection.Assembly)">
            <summary>
            卸载某个 Assembly（例如 MOD 卸载时调用），清理所有与该 Assembly 相关的注册。
            </summary>
        </member>
        <member name="M:JmcModLib.Dependency.ModLinker.CheckerBuilder(JmcModLib.Dependency.ModLinkEvent)">
            <summary>
            构造事件回调（会返回缓存的委托实例供 Init/Dispose 使用）
            </summary>
        </member>
        <member name="M:JmcModLib.Dependency.ModLinker.Checker(Duckov.Modding.ModInfo,Duckov.Modding.ModBehaviour,JmcModLib.Dependency.ModLinkEvent)">
            <summary>
            当 ModManager 触发激活/停用事件时调用。
            注意：遍历时使用 snapshot 以保持线程安全与一致性。
            </summary>
        </member>
        <member name="M:JmcModLib.Dependency.ModLinker.RebuildAssemblyModMap(System.Reflection.Assembly)">
            <summary>
            由于 ConcurrentBag 不支持移除单个元素，这里 rebuild 指定 assembly 的 modName 列表。
            该方法会遍历 _modActions 重新生成该 assembly 的反向映射 Bag（保守重建）。
            </summary>
        </member>
        <member name="M:JmcModLib.Dependency.ModLinker.DumpState">
            <summary>
            调试用：导出当前注册状态（小心调用，不要在高频路径使用）。
            </summary>
        </member>
        <member name="T:JmcModLib.ModBehaviour">
            <summary>
            入口类
            </summary>
        </member>
        <member name="M:JmcModLib.ModBehaviour.OnAfterSetup">
            <summary>
            在模组设置完成后调用
            </summary>
        </member>
        <member name="M:JmcModLib.ModBehaviour.PreloadDependencies">
            <summary>
            遍历列表，将依赖项强行载入内存
            </summary>
        </member>
        <member name="T:JmcModLib.Reflection.MemberAccessor">
            <summary>
            字段 / 属性 的统一高性能访问器。
            </summary>
        </member>
        <member name="P:JmcModLib.Reflection.MemberAccessor.CanRead">
            <summary>
            可读
            </summary>
        </member>
        <member name="P:JmcModLib.Reflection.MemberAccessor.CanWrite">
            <summary>
            可写
            </summary>
        </member>
        <member name="P:JmcModLib.Reflection.MemberAccessor.ValueType">
            <summary>
            成员的值类型（字段类型或属性类型）
            </summary>
            <remarks>
            对于字段，返回字段的类型；对于属性，返回属性的类型。
            不要与 <see cref="P:System.Reflection.MemberInfo.MemberType"/> 混淆，后者返回成员种类（Field/Property）。
            </remarks>
        </member>
        <member name="P:JmcModLib.Reflection.MemberAccessor.MemberType">
            <summary>
            成员种类（字段、属性或索引器）
            </summary>
            <remarks>
            等同于 <see cref="P:System.Reflection.MemberInfo.MemberType"/>，直接暴露以简化访问。
            </remarks>
        </member>
        <member name="P:JmcModLib.Reflection.MemberAccessor.TypedGetter">
            <summary>
            强类型委托，当ref/ref-like/索引器/不可读时为空
            </summary>
        </member>
        <member name="P:JmcModLib.Reflection.MemberAccessor.TypedSetter">
            <summary>
            强类型委托，当ref/ref-like/索引器/不可写时为空
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MemberAccessor.GetValue(System.Object)">
            <summary>
            获取值。
            </summary>
            <param name="target">实例对象，静态则为null</param>
            <returns>属性值</returns>
            <exception cref="T:System.InvalidOperationException">如果是索引器属性或成员不可读</exception>
            <exception cref="T:System.ArgumentNullException">如果非静态情况下 target 为空</exception>
        </member>
        <member name="M:JmcModLib.Reflection.MemberAccessor.SetValue(System.Object,System.Object)">
            <summary>
            设置值。
            </summary>
            <param name="target"> 实例对象，静态则为null </param>
            <param name="value"> 待设置的值 </param>
            <exception cref="T:System.InvalidOperationException">如果是索引器属性或成员不可写</exception>
            <exception cref="T:System.ArgumentNullException">如果非静态情况下 target 为空</exception>
        </member>
        <member name="M:JmcModLib.Reflection.MemberAccessor.GetValue(System.Object,System.Object[])">
            <summary>
            为索引器属性获取值。
            </summary>
            <param name="target">实例对象，静态则为null</param>
            <param name="indexArgs">索引参数</param>
            <returns>属性值</returns>
            <exception cref="T:System.InvalidOperationException">如果不是索引器属性或成员不可读</exception>
            <exception cref="T:System.ArgumentNullException">如果非静态情况下 target 为空</exception>
            <exception cref="T:System.ArgumentException">如果索引器参数数量不匹配</exception>
        </member>
        <member name="M:JmcModLib.Reflection.MemberAccessor.SetValue(System.Object,System.Object,System.Object[])">
            <summary>
            为索引器属性设置值
            </summary>
            <param name="target"> 实例对象，静态则为null </param>
            <param name="value"> 待设置的值 </param>
            <param name="indexArgs"> 索引参数 </param>
            <exception cref="T:System.InvalidOperationException">如果不是索引器属性或成员不可写</exception>
            <exception cref="T:System.ArgumentNullException">如果非静态情况下 target 为空</exception>
            <exception cref="T:System.ArgumentException">如果索引器参数数量不匹配</exception>
        </member>
        <member name="M:JmcModLib.Reflection.MemberAccessor.GetValue``2(``0)">
            <summary>
            泛型特化
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MemberAccessor.SetValue``2(``0,``1)">
            <summary>
            泛型特化
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MemberAccessor.GetValue``1">
            <summary>
            静态重载特化
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MemberAccessor.SetValue``1(``0)">
            <summary>
            静态成员设置值特化
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MemberAccessor.Get(System.Type,System.String)">
            <summary>
            获得一个成员访问器（自动缓存）。
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MemberAccessor.GetIndexer(System.Type,System.Type[])">
             <summary>
             索引器访问器获取，主要用于具有多个索引重载的情况。
             
             <example>
             示例：
             <code>
            class MyList
            {
                private string[] _data = { "Apple", "Banana", "Cat" };
            
                public string this[int index]
                {
                    get => _data[index];
                    set => _data[index] = value;
                }
            
                public string this[int x, int y]
                {
                    get => $"{x},{y}";
                    set { }
                }
            }
             
             var acc1 = MemberAccessor.GetIndexer(typeof(MyList), typeof(int));
             var value1 = acc1.GetValue(list, 1); // "Banana"
            
             var acc2 = MemberAccessor.GetIndexer(typeof(MyList), typeof(int), typeof(int));
             var value2 = acc2.GetValue(list, 3, 5); // "3,5"
             </code>
             </example>
             
             </summary>
             <param name="type"></param>
             <param name="parameterTypes"></param>
             <returns></returns>
             <exception cref="T:System.MissingMemberException"></exception>
        </member>
        <member name="M:JmcModLib.Reflection.MemberAccessor.Get(System.Reflection.MemberInfo)">
            <summary>
            按MemberInfo获取访问器
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MemberAccessor.IsSupportedMember(System.Reflection.MemberInfo)">
            <summary>
            不处理的成员类型
            </summary>
            <returns>若不处理，返回false</returns>
        </member>
        <member name="M:JmcModLib.Reflection.MemberAccessor.GetAll(System.Type,System.Reflection.BindingFlags)">
            <summary>
            获取某类型的所有成员（可选择包含继承）
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MemberAccessor.GetAll``1(System.Reflection.BindingFlags)">
            <summary>
            泛型版本
            </summary>
        </member>
        <member name="T:JmcModLib.Reflection.MethodAccessor">
            <summary>
            用于反射方法
            </summary>
        </member>
        <member name="T:JmcModLib.Reflection.MethodAccessor.ParamSignature">
            <summary>
            参数签名（用于缓存键）
            说明：
              1. null / 未提供参数列表用 Length = -1 表示（即 default ParamSignature）
              2. 泛型参数占位符统一使用 RuntimeTypeHandle = default 记录，使不同的 TUI / T1 在同一方法定义上产生相同签名
            </summary>
        </member>
        <member name="P:JmcModLib.Reflection.MethodAccessor.IsStatic">
            <summary>
            是否为静态
            </summary>
        </member>
        <member name="P:JmcModLib.Reflection.MethodAccessor.TypedDelegate">
            <summary>
            若可用，返回强类型委托 (Func/Action)。实例方法第一个参数是声明类型实例；静态方法不含实例参数。
            不支持 ref/out/泛型定义/包含可变参数的方法。
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.Get(System.Reflection.MethodInfo)">
            <summary>
            从 MethodInfo 获取 MethodAccessor 并缓存
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.GetTypedDelegate">
            <summary>
            获取强类型委托（若不存在抛异常）
            </summary>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.GetAll(System.Type,System.Reflection.BindingFlags)">
            <summary>
            获取某类型的所有方法（可选择包含继承方法）
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.GetAll``1(System.Reflection.BindingFlags)">
            <summary>
            泛型版本
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.Get(System.Type,System.String,System.Type[])">
            <summary>
            获取类型下方法的 MethodAccessor（可匹配参数类型）
            </summary>
            <param name="type"> 类类型 </param>
            <param name="methodName"> 方法名 </param>
            <param name="parameterTypes"> 方法的参数列表类型，泛型位将跳过（可以用typeof(object)或者别的什么占位，但不能填null），不填则默认找第一个（在有多个重载的情况下） </param>
            <returns> 返回一个MethodAccessor，若是泛型方法，需要进一步Make，否则可以直接invoke </returns>
            <exception cref="T:System.MissingMethodException"></exception>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.MakeGeneric(System.Type[])">
            <summary>
            构造泛型方法实例
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.Invoke(System.Object,System.Object[])">
            <summary>
            调用方法（实例/静态）
            </summary>
            <param name="instance"> 实例对象，静态则留空 </param>
            <param name="args"> 调用的参数列表 </param>
            <returns> 返回方法的返回值 </returns>
            <exception cref="T:System.ArgumentNullException"> 实例方法需要实例对象 </exception>
            <exception cref="T:System.InvalidOperationException"> 泛型方法需要先MakeGeneric(...)  </exception>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.Invoke(System.Object)">
            <summary>
            无参特化
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.Invoke(System.Object,System.Object)">
            <summary>
            单参特化
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.Invoke(System.Object,System.Object,System.Object)">
            <summary>
            二参特化
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.Invoke(System.Object,System.Object,System.Object,System.Object)">
            <summary>
            三参特化
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.Invoke``2(``0)">
            <summary>
            无参特化强类型版本
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.Invoke``3(``0,``1)">
            <summary>
            单参特化强类型版本
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.Invoke``4(``0,``1,``2)">
            <summary>
            二参特化强类型版本
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.Invoke``5(``0,``1,``2,``3)">
            <summary>
            三参特化强类型版本
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.InvokeVoid``1(``0)">
            <summary>
            无返回值特化的强类型版本
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.InvokeVoid``2(``0,``1)">
            <summary>
            无返回值特化的强类型版本
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.InvokeVoid``3(``0,``1,``2)">
            <summary>
            无返回值特化的强类型版本
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.InvokeVoid``4(``0,``1,``2,``3)">
            <summary>
            无返回值特化的强类型版本
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.InvokeStatic``1">
            <summary>
            静态特化的强类型版本
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.InvokeStatic``2(``0)">
            <summary>
            静态特化的强类型版本
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.InvokeStatic``3(``0,``1)">
            <summary>
            静态特化的强类型版本
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.InvokeStatic``4(``0,``1,``2)">
            <summary>
            静态特化的强类型版本
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.InvokeStaticVoid">
            <summary>
            静态无返回值特化的强类型版本
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.InvokeStaticVoid``1(``0)">
            <summary>
            静态无返回值特化的强类型版本
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.InvokeStaticVoid``2(``0,``1)">
            <summary>
            静态无返回值特化的强类型版本
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.InvokeStaticVoid``3(``0,``1,``2)">
            <summary>
            静态无返回值特化的强类型版本
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.CreateInvoker(System.Reflection.MethodInfo)">
            <summary>
            创建方法调用委托
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.MethodAccessor.EmitUnboxWithEnumSupport(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>
            对普通值类型执行 Unbox_Any
            对 enum 正确执行底层类型转换 + enum 转换
            对引用类型执行 Castclass
            </summary>
        </member>
        <member name="T:JmcModLib.Reflection.ReflectionAccessorBase">
            <summary>
            所有访问器的基类
            </summary>
        </member>
        <member name="F:JmcModLib.Reflection.ReflectionAccessorBase.DefaultFlags">
            <summary>
            默认搜索所有静态、实例、公有、私有，不搜索继承
            </summary>
        </member>
        <member name="P:JmcModLib.Reflection.ReflectionAccessorBase.Name">
            <summary>
            成员名称
            </summary>
        </member>
        <member name="P:JmcModLib.Reflection.ReflectionAccessorBase.DeclaringType">
            <summary>
            声明该成员的类型
            </summary>
        </member>
        <member name="P:JmcModLib.Reflection.ReflectionAccessorBase.IsStatic">
            <summary>
            该成员是否为静态
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.ReflectionAccessorBase.IsSaveOwner(System.Type)">
            <summary>
            判断指定的类型是否是一个安全的拥有者类型（可作为成员的 DeclaringType）
            </summary>
            <param name="declaringType"></param>
            <returns></returns>
        </member>
        <member name="F:JmcModLib.Reflection.ReflectionAccessorBase._attrCache">
            <summary>
            访问器缓存
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.ReflectionAccessorBase.GetAttribute``1">
            <summary>
            获取指定类型的第一个 Attribute。如果不存在返回 null。
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.ReflectionAccessorBase.HasAttribute``1">
            <summary>
            判断是否具有某个 Attribute。
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.ReflectionAccessorBase.GetAttributes(System.Type)">
            <summary>
            获取指定类型的所有 Attribute。如果 type 为 null，返回所有 Attribute。
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.ReflectionAccessorBase.GetAllAttributes">
            <summary>
            获取所有 Attribute（等价于 GetAttributes(null)）
            </summary>
        </member>
        <member name="T:JmcModLib.Reflection.ReflectionAccessorBase`2">
            <summary>
            MemberAccessor 和 MethodAccessor 的派生基类
            </summary>
            <remarks>
            构造基类
            </remarks>
            <param name="member">成员信息</param>
            <exception cref="T:System.ArgumentNullException"> 若 member 为 null </exception>
        </member>
        <member name="M:JmcModLib.Reflection.ReflectionAccessorBase`2.#ctor(`0)">
            <summary>
            MemberAccessor 和 MethodAccessor 的派生基类
            </summary>
            <remarks>
            构造基类
            </remarks>
            <param name="member">成员信息</param>
            <exception cref="T:System.ArgumentNullException"> 若 member 为 null </exception>
        </member>
        <member name="P:JmcModLib.Reflection.ReflectionAccessorBase`2.CacheCount">
            <summary>
            获取当前缓存的条目数量
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.ReflectionAccessorBase`2.GetOrCreate(`0,System.Func{`0,`1})">
            <summary>
            从 MemberInfo 获取 TAccessor 并缓存（由子类实现具体的创建逻辑）
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.ReflectionAccessorBase`2.ClearCache">
            <summary>
            清空缓存（用于测试或内存管理）
            </summary>
        </member>
        <member name="P:JmcModLib.Reflection.ReflectionAccessorBase`2.MemberInfo">
            <summary>
            底层的 MemberInfo（FieldInfo/PropertyInfo/MethodInfo 等）
            </summary>
        </member>
        <member name="P:JmcModLib.Reflection.ReflectionAccessorBase`2.Name">
            <summary>
            成员名称
            </summary>
        </member>
        <member name="P:JmcModLib.Reflection.ReflectionAccessorBase`2.DeclaringType">
            <summary>
            声明该成员的类型
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.ReflectionAccessorBase`2.GetAttributes(System.Type)">
            <summary>
            获取指定类型的所有 Attribute。如果 type 为 null，返回所有 Attribute。
            </summary>
        </member>
        <member name="T:JmcModLib.Reflection.TypeAccessor">
            <summary>
            类型访问器 - 提供对 Type 本身及其成员的统一访问
            </summary>
        </member>
        <member name="P:JmcModLib.Reflection.TypeAccessor.Type">
            <summary>
            被访问的类型（等同于 MemberInfo）
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.TypeAccessor.Get(System.Type)">
            <summary>
            获取或创建 TypeAccessor（会缓存）
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.TypeAccessor.Get``1">
            <summary>
            泛型版本（会缓存）
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.TypeAccessor.CreateInstance">
            <summary>
            创建实例（调用无参构造函数）
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.TypeAccessor.CreateInstance(System.Object[])">
            <summary>
            创建实例（带参数）
            </summary>
        </member>
        <member name="M:JmcModLib.Reflection.TypeAccessor.CreateInstance``1">
            <summary>
            泛型创建实例
            </summary>
        </member>
        <member name="T:JmcModLib.Storage.JmcES3Manager">
            <summary>
            基于 Easy Save 3 (ES3) 的通用数据存储管理器。
            专用于保存 Mod 的状态、存档数据或复杂对象（区别于 Config 的 JSON 配置）。
            数据默认存储在 Application.persistentDataPath/Saves/JmcModLib/Storage 下。
            </summary>
        </member>
        <member name="M:JmcModLib.Storage.JmcES3Manager.#cctor">
            <summary>
            静态构造函数，确保目录存在
            </summary>
        </member>
        <member name="M:JmcModLib.Storage.JmcES3Manager.GetSettings(System.Reflection.Assembly)">
            <summary>
            获取指定 Assembly 对应的 ES3Settings。
            文件名格式为: ModName.es3
            </summary>
        </member>
        <member name="M:JmcModLib.Storage.JmcES3Manager.Save``1(System.String,``0,System.Reflection.Assembly)">
            <summary>
            保存数据
            </summary>
            <typeparam name="T">数据类型 (支持 Unity 原生类型)</typeparam>
            <param name="key">键</param>
            <param name="value">值</param>
            <param name="asm">调用者的程序集 (自动获取，无需传递)</param>
        </member>
        <member name="M:JmcModLib.Storage.JmcES3Manager.Load``1(System.String,``0,System.Reflection.Assembly)">
            <summary>
            读取数据
            </summary>
            <typeparam name="T">数据类型</typeparam>
            <param name="key">键</param>
            <param name="defaultValue">默认值 (当文件或Key不存在时返回)</param>
            <param name="asm">调用者的程序集 (自动获取，无需传递)</param>
            <returns>读取到的值或默认值</returns>
        </member>
        <member name="M:JmcModLib.Storage.JmcES3Manager.HasKey(System.String,System.Reflection.Assembly)">
            <summary>
            检查是否存在某个 Key
            </summary>
        </member>
        <member name="M:JmcModLib.Storage.JmcES3Manager.DeleteKey(System.String,System.Reflection.Assembly)">
            <summary>
            删除某个 Key
            </summary>
        </member>
        <member name="M:JmcModLib.Storage.JmcES3Manager.DeleteFile(System.Reflection.Assembly)">
            <summary>
            删除该 Mod 的整个存档文件
            </summary>
        </member>
        <member name="M:JmcModLib.Storage.JmcES3Manager.GetSaveFilePath(System.Reflection.Assembly)">
            <summary>
            获取当前 Mod 的存档文件完整路径 (用于调试或手动操作)
            </summary>
        </member>
        <member name="T:JmcModLib.UI.Icon.IconGenerator">
            <summary>
            一些图标的生成器工具
            </summary>
        </member>
        <member name="M:JmcModLib.UI.Icon.IconGenerator.GenerateRestartIcon">
            <summary>
            生成一个重启图标
            </summary>
        </member>
        <member name="T:JmcModLib.UI.SimpleButton">
            <summary>
            通用按钮组件，支持从模板克隆并自动修复布局/图标问题
            </summary>
        </member>
        <member name="P:JmcModLib.UI.SimpleButton.ButtonComp">
            <summary>
            绑定的按钮组件。可能为 null（初始化前或模板不含按钮时会创建）。
            </summary>
        </member>
        <member name="P:JmcModLib.UI.SimpleButton.TextComp">
            <summary>
            按钮的文本组件。可能为 null（初始化前），创建后指向 `TextMeshProUGUI`。
            </summary>
        </member>
        <member name="P:JmcModLib.UI.SimpleButton.BackgroundComp">
            <summary>
            背景图组件。优先使用 `Button.targetGraphic`，否则回退到自身 `Image`。
            </summary>
        </member>
        <member name="P:JmcModLib.UI.SimpleButton.Rect">
            <summary>
            按钮的 `RectTransform`。初始化时确保存在。
            </summary>
        </member>
        <member name="M:JmcModLib.UI.SimpleButton.Create``1(UnityEngine.GameObject,System.String,System.Action,TMPro.TMP_FontAsset,System.Single,System.Single,System.Nullable{UnityEngine.Vector2})">
            <summary>
            创建一个按钮实例
            </summary>
            <param name="parent">父物体</param>
            <param name="text">按钮文字</param>
            <param name="onClick">点击回调</param>
            <param name="font">可选字体</param>
            <param name="width">宽度</param>
            <param name="height">高度</param>
            <param name="anchor">锚点位置 (默认居中)</param>
            <returns>返回挂载了 SimpleButton 的组件</returns>
        </member>
        <member name="M:JmcModLib.UI.SimpleButton.Create(UnityEngine.GameObject,System.String,System.Action,UnityEngine.GameObject,TMPro.TMP_FontAsset,System.Single,System.Single,System.Nullable{UnityEngine.Vector2})">
            <summary>
            创建按钮 (指定 GameObject 模板或默认)
            </summary>
        </member>
        <member name="M:JmcModLib.UI.SimpleButton.SetTextColor(UnityEngine.Color)">
            <summary>
            链式调用：设置文字颜色
            </summary>
        </member>
        <member name="M:JmcModLib.UI.SimpleButton.SetBackgroundColor(UnityEngine.Color)">
            <summary>
            链式调用：设置背景颜色
            </summary>
        </member>
        <member name="M:JmcModLib.UI.SimpleButton.ClearIcons">
            <summary>
            清理按钮上除背景外的所有图片（移除模板自带的图标）
            </summary>
        </member>
        <member name="M:JmcModLib.UI.SimpleButton.ClearText">
            <summary>
            清空文字（隐藏或设置为空）
            </summary>
        </member>
        <member name="M:JmcModLib.UI.SimpleButton.SetIcon(UnityEngine.Sprite,System.Nullable{UnityEngine.Vector2})">
            <summary>
            设置为一个居中的纯图标按钮
            </summary>
            <param name="sprite">图标资源</param>
            <param name="size">图标大小，默认 32x32</param>
        </member>
        <member name="T:JmcModLib.UI.SimpleConfirmUI">
            <summary>
            一个通用的简易确认弹窗组件，用于在 Canvas 上显示带有遮罩的模态对话框（包含确认/取消按钮）。
            </summary>
        </member>
        <member name="P:JmcModLib.UI.SimpleConfirmUI.IsActive">
            <summary>
            是否active
            </summary>
        </member>
        <member name="M:JmcModLib.UI.SimpleConfirmUI.Show(UnityEngine.Transform,System.String,System.Action,UnityEngine.Component,System.Action,System.String,System.String,System.Nullable{UnityEngine.Color})">
            <summary>
            显示确认弹窗，并尝试从指定的 UI 组件模板中提取字体样式（推荐使用此重载以保持游戏风格一致）。
            </summary>
            <param name="contextObject">上下文对象，系统将从该对象的父级中查找 Canvas 以决定弹窗挂载位置。若找不到则会在场景中全局查找。</param>
            <param name="message">弹窗中间显示的提示消息内容。</param>
            <param name="onConfirm">点击“确认”按钮时的回调操作。</param>
            <param name="styleTemplate">样式模板组件。弹窗将尝试从该组件（或其子物体）上的 TextMeshProUGUI 中提取字体，以便让弹窗字体与游戏原生 UI 保持一致。</param>
            <param name="onCancel">点击“取消”按钮或按下 ESC 键时的回调操作。默认为 null。</param>
            <param name="confirmText">确认按钮显示的文本。默认为 "Confirm"。</param>
            <param name="cancelText">取消按钮显示的文本。默认为 "Cancel"。</param>
            <param name="confirmColor">确认按钮的文本颜色。默认为红色（警示色），若传 null 则使用默认样式。</param>
        </member>
        <member name="M:JmcModLib.UI.SimpleConfirmUI.Show(UnityEngine.Transform,System.String,System.Action,System.Action,TMPro.TMP_FontAsset,System.String,System.String,System.Nullable{UnityEngine.Color})">
            <summary>
            显示确认弹窗，允许直接指定字体资源（核心实现方法）。
            </summary>
            <param name="contextObject">上下文对象，系统将从该对象的父级中查找 Canvas 以决定弹窗挂载位置。若找不到则会在场景中全局查找。</param>
            <param name="message">弹窗中间显示的提示消息内容。</param>
            <param name="onConfirm">点击“确认”按钮时的回调操作。</param>
            <param name="onCancel">点击“取消”按钮或按下 ESC 键时的回调操作。默认为 null。</param>
            <param name="font">指定的 TextMeshPro 字体资源。如果为 null，将使用 TMP 的默认字体。</param>
            <param name="confirmText">确认按钮显示的文本。默认为 "Confirm"。</param>
            <param name="cancelText">取消按钮显示的文本。默认为 "Cancel"。</param>
            <param name="confirmColor">确认按钮的文本颜色。默认为红色（警示色），若传 null 则使用默认样式。</param>
        </member>
        <member name="M:JmcModLib.UI.SimpleConfirmUI.Close">
            <summary>
            强制关闭并销毁当前显示的确认弹窗。
            </summary>
        </member>
        <member name="T:JmcModLib.Utils.ComponentHelper">
            <summary>
            一些用来往GameObject里加Component的方法
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ComponentHelper.AddComponentIfNeeded``1(UnityEngine.GameObject,System.Action{``0},System.String)">
            <summary>
            确保组件被添加并初始化
            <example>
            示例：
            <code>
            var ret = Utils.ComponentHelper.AddComponentIfNeeded&lt;UI.ModEntryDragHandler>(__instance.gameObject, handler => handler.Setup(__instance), "ModEntryDragHandler 已添加并初始化");
            if (!ret)
            {
                ModLogger.Debug("ModEntryDragHandler已经被添加过了");
            }
            </code>
            </example>
            </summary>
            <typeparam name="T">组件类型</typeparam>
            <param name="instance">目标 GameObject</param>
            <param name="initializeMethod">初始化方法，接受该组件的实例作为参数</param>
            <param name="info">可选的参数，成功添加的日志信息，如果有传递，会打印到Debug日志中</param>
            <returns>如果组件已存在返回 false，成功添加返回 true</returns>
            
        </member>
        <member name="M:JmcModLib.Utils.ComponentHelper.AddComponentAlways``1(UnityEngine.GameObject,System.Action{``0},System.String)">
            <summary>
            若GameObject中已存在component，初始化，否则添加并初始化
            </summary>
            <typeparam name="T">组件类型</typeparam>
            <param name="instance">目标 GameObject</param>
            <param name="initializeMethod">初始化方法，接受该组件的实例作为参数</param>
            <param name="info">可选的参数，成功添加的日志信息，如果有传递，会打印到Debug日志中</param>
            <returns> 返回组件 </returns>
        </member>
        <member name="M:JmcModLib.Utils.ComponentHelper.AddComponentOr``1(UnityEngine.GameObject,System.Action{``0},System.Action{``0},System.String)">
            <summary>
            如果GameObject中已存在component组件，执行onComponentFound，否则添加
            </summary>
            <typeparam name="T">组件类型</typeparam>
            <param name="instance">目标 GameObject</param>
            <param name="initializeMethod">初始化方法，接受该组件的实例作为参数</param>
            <param name="onComponentFound">待执行的函数</param>
            <param name="info">可选的参数，成功添加的日志信息，如果有传递，会打印到Debug日志中</param>
            <returns></returns>
        </member>
        <member name="T:JmcModLib.Utils.ModDependencyResult">
            <summary>
            MOD依赖检测结果
            </summary>
        </member>
        <member name="T:JmcModLib.Utils.MethodSignature">
            <summary>
            方法签名定义
            </summary>
        </member>
        <member name="T:JmcModLib.Utils.ModDependencyChecker">
            <summary>
            MOD依赖检测器 - 通用模块
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ModDependencyChecker.RequireMethod(System.String,System.Type[],System.Boolean)">
            <summary>
            添加必需的方法签名
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ModDependencyChecker.RequireMethods(JmcModLib.Utils.MethodSignature[])">
            <summary>
            批量添加必需的方法
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ModDependencyChecker.Check">
            <summary>
            执行完整检测
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ModDependencyChecker.IsAvailable">
            <summary>
            快速检查是否完全可用
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ModDependencyChecker.GetMethod(System.String)">
            <summary>
            获取已缓存的方法访问器（需先调用Check）
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ModDependencyChecker.TryInvoke(System.String,System.Object,System.Object@,System.Object[])">
            <summary>
            尝试调用方法（自动处理异常）
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ModDependencyChecker.TryInvokeVoid(System.String,System.Object,System.Object[])">
            <summary>
            尝试调用void方法
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ModDependencyChecker.ResetCache">
            <summary>
            重置缓存（用于MOD热重载等场景）
            </summary>
        </member>
        <member name="T:JmcModLib.Utils.ModDependencyExtensions">
            <summary>
            使用示例与扩展方法
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ModDependencyExtensions.CreateModSettingChecker(System.Version)">
            <summary>
            创建ModSetting的依赖检测器（预配置版本）
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ModDependencyExtensions.ForMod(System.String,System.String,System.String)">
            <summary>
            创建通用检测器的快捷方法
            </summary>
        </member>
        <member name="T:JmcModLib.Utils.L10n">
            <summary>
            多语言本地化系统（按程序集管理）
            </summary>
        </member>
        <member name="P:JmcModLib.Utils.L10n.CurrentLanguage">
            <summary>
            当前语言
            </summary>
        </member>
        <member name="E:JmcModLib.Utils.L10n.LanguageChanged">
            <summary>
            语言变更后的事件，不建议订阅<c>LocalizationManager.CurrentLanguage</c>，不然可能本地化不及时生效
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.L10n.Dispose">
            <summary>
            当 JmcModLib 或宿主 MOD 卸载时调用
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.L10n.IsRegistered(System.Reflection.Assembly)">
            <summary>
            判断某程序集是否已经被注册过语言文件。
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.L10n.Register(System.String,UnityEngine.SystemLanguage,System.Reflection.Assembly)">
            <summary>
            注册当前程序集的本地化文件夹路径（例如 "Mods/MyMod/Lang"）。
            若找不到指定的备用语言对应的文件，会将指定文件夹的第一个 `.csv` 文件作为备用语言文件。
            </summary>
            <param name="langFolderRelative">存放本地化csv的相对路径，默认为“Lang”</param>
            <param name="fallbackLang">指定某语言文件不存在时的备份语言，默认为英语</param>
            <param name="assembly">程序集，默认为调用者</param>
        </member>
        <member name="M:JmcModLib.Utils.L10n.UnRegister(System.Reflection.Assembly)">
            <summary>
            反注册当前程序集的本地化数据。
            </summary>
            <param name="assembly">程序集，默认为调用者</param>
        </member>
        <member name="M:JmcModLib.Utils.L10n.Get(System.String,System.Reflection.Assembly)">
            <summary>
            翻译当前程序集的键值
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.L10n.GetFormat(System.String,System.Reflection.Assembly,System.Object[])">
            <summary>
            获取带格式化占位符的本地化文本
            使用 string.Format(key, args)
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.L10n.GetF(System.String,System.Reflection.Assembly,System.Object[])">
            <summary>
            简写版（推荐）
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.L10n.OnLanguageChanged(UnityEngine.SystemLanguage)">
            <summary>
            当游戏语言切换时自动更新
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.L10n.LoadForPath(System.String)">
            <summary>
            从路径加载
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.L10n.LoadForAssembly(System.Reflection.Assembly,UnityEngine.SystemLanguage)">
            <summary>
            加载指定程序集和语言
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.L10n.GetLanguageFileName(UnityEngine.SystemLanguage)">
            <summary>
            根据 SystemLanguage 返回语言文件名
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.L10n.LoadCSV(System.String)">
            <summary>
            使用游戏自带的 CSV 工具加载
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.L10n.Exist(System.Reflection.Assembly)">
            <summary>
            返回程序集是否注册了本地化文本
            </summary>
            <param name="asm"></param>
            <returns></returns>
        </member>
        <member name="M:JmcModLib.Utils.L10n.ExistKey(System.String,System.Reflection.Assembly)">
            <summary>
            判断程序集在当前语言是否注册了某个Key
            </summary>
        </member>
        <member name="T:JmcModLib.Utils.LogConfigUIFlags">
            <summary>
            标记要构建的日志配置UI元素
            </summary>
        </member>
        <member name="F:JmcModLib.Utils.LogConfigUIFlags.None">
            <summary>无 </summary>
        </member>
        <member name="F:JmcModLib.Utils.LogConfigUIFlags.LogLevel">
            <summary>日志等级选项下拉列表 </summary>
        </member>
        <member name="F:JmcModLib.Utils.LogConfigUIFlags.FormatFlags">
            <summary>格式标志复选框 </summary>
        </member>
        <member name="F:JmcModLib.Utils.LogConfigUIFlags.TestButtons">
            <summary>测试按钮 </summary>
        </member>
        <member name="F:JmcModLib.Utils.LogConfigUIFlags.Default">
            <summary>默认选项（日志等级 + 格式标志） </summary>
        </member>
        <member name="F:JmcModLib.Utils.LogConfigUIFlags.All">
            <summary>所有选项 </summary>
        </member>
        <member name="T:JmcModLib.Utils.LogLevel">
            <summary>
            打印级别
            </summary>
        </member>
        <member name="F:JmcModLib.Utils.LogLevel.None">
            <summary> 不打印任何，低于任何等级 </summary>
        </member>
        <member name="F:JmcModLib.Utils.LogLevel.Trace">
            <summary> 主要用于打印出函数入函数 </summary>
        </member>
        <member name="F:JmcModLib.Utils.LogLevel.Debug">
            <summary> Debug </summary>
        </member>
        <member name="F:JmcModLib.Utils.LogLevel.Info">
            <summary> Info </summary>
        </member>
        <member name="F:JmcModLib.Utils.LogLevel.Warn">
            <summary> Warn </summary>
        </member>
        <member name="F:JmcModLib.Utils.LogLevel.Error">
            <summary> Error </summary>
        </member>
        <member name="F:JmcModLib.Utils.LogLevel.Fatal">
            <summary> Fatal 错误，在Debug模式下会抛出异常，在Release模式下会打印信息 </summary>
        </member>
        <member name="F:JmcModLib.Utils.LogLevel.All">
            <summary> 高于所有等级 </summary>
        </member>
        <member name="T:JmcModLib.Utils.LogFormatFlags">
            <summary>
            日志格式配置项（位标志）
            </summary>
        </member>
        <member name="F:JmcModLib.Utils.LogFormatFlags.None">
            <summary> 不显示任何东西，占位 </summary>
        </member>
        <member name="F:JmcModLib.Utils.LogFormatFlags.Timestamp">
            <summary>显示时间戳</summary>
        </member>
        <member name="F:JmcModLib.Utils.LogFormatFlags.Level">
            <summary>显示日志等级</summary>
        </member>
        <member name="F:JmcModLib.Utils.LogFormatFlags.Caller">
            <summary>显示调用方法名</summary>
        </member>
        <member name="F:JmcModLib.Utils.LogFormatFlags.LineNumber">
            <summary>显示行号</summary>
        </member>
        <member name="F:JmcModLib.Utils.LogFormatFlags.FilePath">
            <summary>显示文件路径</summary>
        </member>
        <member name="F:JmcModLib.Utils.LogFormatFlags.Tag">
            <summary>显示 TAG（从 ModRegistry 获取）</summary>
        </member>
        <member name="F:JmcModLib.Utils.LogFormatFlags.StackTrace">
            <summary>显示调用栈（仅函数名）</summary>
        </member>
        <member name="F:JmcModLib.Utils.LogFormatFlags.Colored">
            <summary>彩色输出（仅限支持的终端）</summary>
        </member>
        <member name="F:JmcModLib.Utils.LogFormatFlags.Default">
            <summary>默认格式：TAG + 时间戳 + 等级 + 调用方法 + 行号</summary>
        </member>
        <member name="F:JmcModLib.Utils.LogFormatFlags.All">
            <summary>完整格式：包含所有信息</summary>
        </member>
        <member name="F:JmcModLib.Utils.LogFormatFlags.Minimal">
            <summary>精简格式：只有等级和消息</summary>
        </member>
        <member name="T:JmcModLib.Utils.AssemblyLoggerConfig">
            <summary>
            单个 Assembly 的日志配置
            </summary>
        </member>
        <member name="P:JmcModLib.Utils.AssemblyLoggerConfig.MinLevel">
            <summary>
            该 Assembly 的最低输出等级
            </summary>
        </member>
        <member name="P:JmcModLib.Utils.AssemblyLoggerConfig.FormatFlags">
            <summary>
            日志格式配置
            </summary>
        </member>
        <member name="T:JmcModLib.Utils.ModLogger">
            <summary>
            一个打印类
            </summary>
        </member>
        <member name="F:JmcModLib.Utils.ModLogger.DefaultLogLevel">
            <summary> 默认等级 </summary>
        </member>
        <member name="M:JmcModLib.Utils.ModLogger.GetOrCreateConfig(System.Reflection.Assembly)">
            <summary>
            获取或创建指定 Assembly 的配置
            </summary>
        </member>
        <member name="T:JmcModLib.Utils.ModLogger.ColorMode">
            <summary>
            颜色模式（订阅最多的那个控制台用不了，留接口）
            </summary>
        </member>
        <member name="F:JmcModLib.Utils.ModLogger.ColorMode.None">
            <summary> 无 </summary>
        </member>
        <member name="F:JmcModLib.Utils.ModLogger.ColorMode.Unity">
            <summary> Unity </summary>
        </member>
        <member name="F:JmcModLib.Utils.ModLogger.ColorMode.Ansi">
            <summary> Ansi </summary>
        </member>
        <member name="T:JmcModLib.Utils.ModLogger.ModLoggerColor">
            <summary>
            控制输出的颜色，需要终端支持
            </summary>
        </member>
        <member name="F:JmcModLib.Utils.ModLogger.ModLoggerColor.Mode">
            <summary>
            当前颜色模式
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ModLogger.ModLoggerColor.ColorizeLevel(JmcModLib.Utils.LogLevel,System.String)">
            <summary>
            根据打印等级渲染对应的颜色
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ModLogger.RegisterAssembly(System.Reflection.Assembly,JmcModLib.Utils.LogLevel,JmcModLib.Utils.LogFormatFlags,JmcModLib.Utils.LogConfigUIFlags)">
            <summary>
            注册 Assembly 的元信息（供 ModRegistry 调用）
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ModLogger.UnregisterAssembly(System.Reflection.Assembly)">
            <summary>
            反注册 Assembly（供 ModRegistry 调用）
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ModLogger.SetLogLevel(JmcModLib.Utils.LogLevel,System.Reflection.Assembly)">
            <summary>
            设置当前调用 Assembly 的最低日志等级
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ModLogger.SetFormatFlags(JmcModLib.Utils.LogFormatFlags,System.Reflection.Assembly)">
            <summary>
            设置当前调用 Assembly 的日志格式
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ModLogger.HasFormatFlag(JmcModLib.Utils.LogFormatFlags,JmcModLib.Utils.LogFormatFlags)">
            <summary>
            判断两个日志格式是否相交
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ModLogger.HasFormatFlag(JmcModLib.Utils.LogFormatFlags,System.Reflection.Assembly)">
            <summary>
            判断当前调用 Assembly 是否包含指定日志格式标志
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ModLogger.ToggleFormatFlag(JmcModLib.Utils.LogFormatFlags,System.Reflection.Assembly)">
            <summary>
            将当前调用 Assembly 的指定日志格式标志取反
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ModLogger.GetLogLevel(System.Reflection.Assembly)">
            <summary>
            获取当前调用 Assembly 的最低日志等级，若不存在，则设为默认并返回
            </summary>
            <param name="asm"> 留空则获取调用者 Assembly 的配置 </param>
            <returns>
            返回日志等级，若未注册则设置为默认等级并返回
            </returns>
        </member>
        <member name="M:JmcModLib.Utils.ModLogger.GetFormatFlags(System.Reflection.Assembly)">
            <summary>
            获取当前调用 Assembly 的日志格式配置
            </summary>
            <param name="asm"> 留空则获取调用者 Assembly 的配置 </param>
            <returns>
            返回日志格式配置，若未注册则返回全局配置
            </returns>
        </member>
        <member name="M:JmcModLib.Utils.ModLogger.ShouldLog(System.Reflection.Assembly,JmcModLib.Utils.LogLevel,JmcModLib.Utils.LogFormatFlags@)">
            <summary>
            判断是否应该输出日志
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ModLogger.Format(System.Reflection.Assembly,JmcModLib.Utils.LogFormatFlags,JmcModLib.Utils.LogLevel,System.String,System.String,System.String,System.Int32)">
            <summary>
            根据格式配置格式化输出内容
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ModLogger.Log(System.Nullable{JmcModLib.Utils.LogLevel},System.String,System.Reflection.Assembly,System.String,System.String,System.Int32)">
            <summary>
            手动指定等级输出日志，为空不打印
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ModLogger.Trace(System.String,System.Reflection.Assembly,System.String,System.String,System.Int32)">
            <summary>
            使用Trace输出（使用调用 Assembly 的配置）
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ModLogger.Debug(System.String,System.Reflection.Assembly,System.String,System.String,System.Int32)">
            <summary>
            使用Debug输出（使用调用 Assembly 的配置）
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ModLogger.Info(System.String,System.Reflection.Assembly,System.String,System.String,System.Int32)">
            <summary>
            Info输出（使用调用 Assembly 的配置）
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ModLogger.Warn(System.String,System.Exception,System.Reflection.Assembly,System.String,System.String,System.Int32)">
            <summary>
            Warn输出（使用调用 Assembly 的配置）
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ModLogger.Error(System.String,System.Exception,System.Reflection.Assembly,System.String,System.String,System.Int32)">
            <summary>
            Error输出，其中若传递异常，会换行并输出异常（使用调用 Assembly 的配置）
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ModLogger.Fatal(System.Exception,System.String,System.Reflection.Assembly,System.String,System.String,System.Int32)">
            <summary>
            Fatal输出，在Debug模式下会直接抛出异常，在Release模式下会打印异常信息
            </summary>
            <param name="ex"> 待处理的异常 </param>
            <param name="msg"> 打印的附加信息 </param>
            <param name="asm"> 程序集，留空则为调用者 </param>
            <param name="caller"> 调用者函数名，留空自动填充 </param>
            <param name="file"> 调用者函数名，留空自动填充 </param>
            <param name="line"> 调用者函数名，留空自动填充 </param>
        </member>
        <member name="T:JmcModLib.Utils.ReflectionHelper">
            <summary>
            Emit实现带缓存的反射辅助库
            </summary>
        </member>
        <member name="M:JmcModLib.Utils.ReflectionHelper.GetFieldValue``1(System.Object,System.String)">
            <summary>
            获取obj名为fieldName的字段
            </summary>
            <typeparam name="T">字段的类型</typeparam>
            <param name="obj">目标对象</param>
            <param name="fieldName">字段名称</param>
            <returns>返回被获取的字段</returns>
            <exception cref="T:System.ArgumentNullException">传入obj为空</exception>
            <exception cref="T:System.MissingFieldException">不存在字段</exception>
            <exception cref="T:System.InvalidCastException">字段类型不匹配</exception>
        </member>
        <member name="M:JmcModLib.Utils.ReflectionHelper.SetFieldValue``1(System.Object,System.String,``0)">
            <summary>
            设置字段的值为value
            </summary>
            <typeparam name="T">字段类型</typeparam>
            <param name="obj">目标对象</param>
            <param name="fieldName">字段名称</param>
            <param name="value">待设置的值</param>
            <exception cref="T:System.ArgumentNullException">传入obj为空</exception>
            <exception cref="T:System.MissingFieldException">不存在字段</exception>
        </member>
        <member name="M:JmcModLib.Utils.ReflectionHelper.CallMethod``1(System.Object,System.String,System.Object[])">
            <summary>
            获取一个有返回值的Method
            </summary>
            <typeparam name="T">返回值类型</typeparam>
            <param name="obj">目标对象</param>
            <param name="methodName">方法名</param>
            <param name="args">传入的参数</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">obj为空</exception>
            <exception cref="T:System.MissingMethodException">方法不存在</exception>
            <exception cref="T:System.InvalidCastException">返回值类型不匹配</exception>
        </member>
        <member name="M:JmcModLib.Utils.ReflectionHelper.CallVoidMethod(System.Object,System.String,System.Object[])">
            <summary>
            获取一个void返回值的方法
            </summary>
            <param name="obj">目标对象</param>
            <param name="methodName">方法名</param>
            <param name="args">传入的参数</param>
            <exception cref="T:System.ArgumentNullException">obj为空</exception>
            <exception cref="T:System.MissingMethodException">方法不存在</exception>
        </member>
        <member name="M:JmcModLib.Utils.ReflectionHelper.CallStaticMethod``1(System.Type,System.String,System.Object[])">
            <summary>
            调用一个带有返回值的静态方法
            </summary>
            <typeparam name="T">返回值类型</typeparam>
            <param name="type">类型</param>
            <param name="methodName">方法名称</param>
            <param name="args">参数列表</param>
            <returns></returns>
            <exception cref="T:System.MissingMethodException">找不到静态方法</exception>
            <exception cref="T:System.InvalidCastException">返回值不正确</exception>
        </member>
        <member name="M:JmcModLib.Utils.ReflectionHelper.CallStaticMethodWithOut``1(System.Type,System.String,System.Object[],``0@)">
            <summary>
            调用一个带out参数的静态方法
            </summary>
            <typeparam name="TOut"></typeparam>
            <param name="type"></param>
            <param name="methodName"></param>
            <param name="args"></param>
            <param name="outValue"></param>
            <returns></returns>
            <exception cref="T:System.MissingMethodException"></exception>
            <exception cref="T:System.InvalidCastException"></exception>
        </member>
        <member name="T:ExprHelper">
            <summary>
            解析表达式的一些库
            </summary>
        </member>
        <member name="P:ExprHelper.EnableCache">
            <summary>
            是否开启缓存，不建议修改
            </summary>
        </member>
        <member name="P:ExprHelper.AccessMode">
            <summary>
            生成Accessor的后端，不建议修改，默认为Emit
            </summary>
        </member>
        <member name="T:ExprHelper.MemberAccessMode">
            <summary>
            生成Accessor的后端模式
            </summary>
        </member>
        <member name="F:ExprHelper.MemberAccessMode.Reflection">
            <summary>
            直接反射
            </summary>
        </member>
        <member name="F:ExprHelper.MemberAccessMode.ExpressionTree">
            <summary>
            表达式树实现
            </summary>
        </member>
        <member name="F:ExprHelper.MemberAccessMode.Emit">
            <summary>
            Emit实现
            </summary>
        </member>
        <member name="F:ExprHelper.MemberAccessMode.Default">
            <summary>
            默认值，默认为Emit
            </summary>
        </member>
        <member name="M:ExprHelper.Expect``2">
            <summary>
            仅供检查类型别名嵌套关系是否正确的辅助函数
            </summary>
        </member>
        <member name="T:ExprHelper.MemberAccessors">
            <summary>
            类型访问器辅助类
            </summary>
        </member>
        <member name="M:ExprHelper.MemberAccessors.#ctor(System.Delegate,System.Delegate)">
            <summary>
            类型访问器辅助类
            </summary>
        </member>
        <member name="M:ExprHelper.GetOrCreateAccessors``1(System.Linq.Expressions.Expression{System.Func{``0}},System.Reflection.Assembly)">
            <summary>
            从一个变量自动构造getter函数与setter函数，调用形式形如：
            <example>
            <code>
             var (gf, sf) = ExprHelper.GetOrCreateAccessors(() => obj.Field)
            </code>
            </example>
            </summary>
            <typeparam name="T">变量的类型</typeparam>
            <param name="expr">构造表达式，形如<c>() => obj.field </c></param>
            <param name="assembly">程序集，默认为调用者</param>
            <returns>返回由getter和setter组成的对，若目标为只读或者只写，在调用错误访问器时会抛出InvalidOperationException异常</returns>
            <exception cref="T:System.ArgumentException">表达式格式不正确、目标字段或属性不正确</exception>
            <exception cref="T:System.InvalidOperationException">实例对象为空、模式选择不正确</exception>
        </member>
        <member name="M:ExprHelper.GetOrCreateAccessors``1(System.Linq.Expressions.Expression{System.Func{``0}},System.Boolean@,System.Reflection.Assembly)">
            <summary>
            从一个变量自动构造getter函数与setter函数，并检查是否命中缓存，调用形式形如：
            <example>
            <code>
            var (g, s) = ExprHelper.GetOrCreateAccessors(() => a.Field, out bool hit);
            </code>
            </example>
            </summary>
            <typeparam name="T">变量的类型</typeparam>
            <param name="expr">构造表达式，形如<c>() => obj.field </c></param>
            <param name="cacheHit">是否命中缓存</param>
            <param name="assembly">程序集，默认为调用者</param>
            <returns>返回由getter和setter组成的对，若目标为只读或者只写，在调用错误访问器时会抛出InvalidOperationException异常</returns>
            <exception cref="T:System.ArgumentException">表达式格式不正确、目标字段或属性不正确</exception>
            <exception cref="T:System.InvalidOperationException">实例对象为空、模式选择不正确</exception>
        </member>
        <member name="M:ExprHelper.CreateAccessorsByExpressionTree``1(System.Reflection.MemberInfo,System.Object)">
            <summary>
            创建 getter/setter
            </summary>
        </member>
        <member name="M:ExprHelper.CreateAccessorsByEmit``1(System.Reflection.MemberInfo,System.Object)">
            <summary>
            使用 DynamicMethod + IL Emit 创建 getter/setter
            </summary>
        </member>
        <member name="M:ExprHelper.ClearAssemblyCache(System.Reflection.Assembly)">
            <summary>
            清理某个 Assembly 的缓存
            </summary>
        </member>
        <member name="M:ExprHelper.ClearAll">
            <summary>
            清理所有缓存
            </summary>
        </member>
    </members>
</doc>
